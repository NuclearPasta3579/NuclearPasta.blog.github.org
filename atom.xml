<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://NuclearPasta3579.github.io/</id>
    <title>Nuclear_pasta&apos;s algorithm blog</title>
    <updated>2023-08-08T11:14:10.855Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://NuclearPasta3579.github.io/"/>
    <link rel="self" href="https://NuclearPasta3579.github.io/atom.xml"/>
    <subtitle>Algorithm bolg</subtitle>
    <logo>https://NuclearPasta3579.github.io/images/avatar.png</logo>
    <icon>https://NuclearPasta3579.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Nuclear_pasta&apos;s algorithm blog</rights>
    <entry>
        <title type="html"><![CDATA[组合]]></title>
        <id>https://NuclearPasta3579.github.io/post/zu-he/</id>
        <link href="https://NuclearPasta3579.github.io/post/zu-he/">
        </link>
        <updated>2023-08-08T09:23:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1组合数">1.组合数</h1>
<p>组合数 (^n_m) 的意义为在 n 个元素中选 m 个元素的方法数（不考虑顺序），常见求法有三种：</p>
<ol>
<li>转移公式 (<sup>n_m)=(</sup>{n-1}<em>m)+(^{n-1}</em>{m-1})，预处理 O(nm)，询问 O(1)，空间复杂度 O(nm)。</li>
<li>公式 (^n_m)=n \cdot (n-1) \cdot (n-2)…(n-m+1)\div m!，询问 O(m)，空间复杂度 O(1)。</li>
<li>公式 (^n_m) = \frac {n!} {m!(n-m)!},预处理复杂度 O(n)，询问 O(1)，空间复杂度 O(n)。</li>
</ol>
<p>*注：取模时第二种方法和第三种方法求解涉及逆元，详情看<a href="https://nuclearpasta3579.github.io/post/shu-lun">数论篇</a><br>
例题：<a href="https://www.luogu.com.cn/problem/P1641">P1641 [SCOI2010] 生成字符串</a><br>
我们可以将这一位为 1 看作右上走，这一位为 0 看作右下走，求从 (0,0) 到 (n-m,n+m) 的方法，有 (^{n+m}<em>m) 种。据题意，过程中不能到 y=-1 的点，排除的路线相当于从 (0,-2) 到 (n-m,n+m) 的路线，有 (^{n+m}</em>{m-1}) 种，故共 (<sup>{n+m}_m)-(</sup>{n+m}_{m-1}) 种。<br>
使用第二种或第三种方法求解可通过。</p>
<h1 id="2卢卡斯定理">2.卢卡斯定理</h1>
<p>当 p 为质数时，根据卢卡斯定理，(^n_m)\equiv (^{n \bmod p}<em>{m \bmod p})\cdot (^{[\frac{n}{p}]}</em>{[\frac{m}{p}]})(\bmod p)。<br>
使用卢卡斯定理会使时间复杂度变为 O(p\log_p n)。<br>
模板题代码：</p>
<pre><code>#include&lt;cstdio&gt;
using namespace std;
inline long long exgcd(long long x,long long y,long long &amp;a,long long &amp;b){
    if(y==0){
    	a=1,b=0;
		return x;
	}
    else {
    	long long plok=exgcd(y,x%y,b,a);
    	b-=x/y*a;
    	return plok;
    }
}
long long n,p,m,ans=0,t;
long long s[5000009],l[5000009],a[5000009];
inline void cin(long long &amp;x){
    x=0;
    char c=' ';
    bool f=false;
    while((c&lt;'0'||c&gt;'9')&amp;&amp;c!='-')c=getchar();
    if(c=='-'){
        f=true;
        c=getchar();
    }
    while(c&lt;='9'&amp;&amp;c&gt;='0'){
        x=x*10+c-'0';
        c=getchar();
    }
    if(f)x=-x;
}
inline long long lucus(long long n,long long m){
    if(m&gt;n)return 0;
    else if(n&gt;=p)return lucus(n/p,m/p)*lucus(n%p,m%p)%p;
    else return s[n]*l[m]%p*l[n-m]%p;
}
int main(){
    cin(t);
    while(t--){
    cin(n),cin(m),cin(p);
    s[0]=1;
    n+=m;
    for(int i=1;i&lt;p;i++){
        s[i]=s[i-1]*i%p;
    }
    long long y;
    l[p-1] =p-1;//威尔逊定理
    for(int i=p-2;i&gt;=0;i--){
        l[i]=l[i+1]*(i+1)%p;
    }
    printf(&quot;%lld\n&quot;,lucus(n,m));
    }
    return 0;
}
</code></pre>
<h1 id="3容斥">3.容斥</h1>
<p>容斥其实只是一种思想，在数学的学习中也能学到。<br>
较为专业的解释其实非常简单。<br>
容斥的基本形式的解释方式为：对于若干集合 A_1,A_2,...,A_n，有 |A_1\cup A_2 \cup A_3 \cup A_4 \cup A_5 ...A_n|=\sum^{n}<em>{i=1}\sum (-1)^{i-1}\times |A</em>{a_1}\cap A_{a_2}\cap...A_{a_n}|。具体推导可以用韦恩图。<br>
例题：<a href="https://www.luogu.com.cn/problem/P1450">P1450 [HAOI2008] 硬币购物</a><br>
这道题先用 <code>dp</code> 可以进行预处理，设 dp_i 为总价为 i 而每种货币可无限制使用的方法数，则可以递推，复杂度 O(\max s)，可以直接默认 \max x=10^5。<br>
对于每个询问，我们枚举其中若干种货币必然使用超限的方法数（i 硬币超限对应先用掉 d_i+1 枚硬币 i），利用容斥原理可以得解（O(n)）。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
long long c[5],n,d[5],s;
long long dp[100005],ans;
inline void srh(long long k,long long res,long long cnt){
    ans+=(cnt%2==0)?dp[res]:-dp[res];
    for(int i=k+1;i&lt;=4;i++){
        if(res&gt;=c[i]*(d[i]+1)){
            srh(i,res-c[i]*(d[i]+1),cnt+1);
        }
    }
}
int main(){
    scanf(&quot;%lld %lld %lld %lld%lld&quot;,&amp;c[1],&amp;c[2],&amp;c[3],&amp;c[4],&amp;n);
    dp[0]=1;
    for(int i=1;i&lt;=4;i++){
        for(int j=c[i];j&lt;=100000;j++){
            dp[j]+=dp[j-c[i]];
        }
    }
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%lld %lld %lld %lld %lld&quot;,&amp;d[1],&amp;d[2],&amp;d[3],&amp;d[4],&amp;s);
        ans=0,srh(0,s,0);
        printf(&quot;%lld\n&quot;,ans);
    }
}
</code></pre>
<h1 id="4卡特兰数">4.卡特兰数</h1>
<p>卡特兰数指从 (1,1) 到 (n,n) 使横坐标不大于纵坐标的方法数。<br>
卡特兰数的一种求法为 (<em>n<sup>{2n})-(</sup>{2n}</em>{n-1}) 或 \frac{(^{2n}<em>n)}{n+1}（O(n)），另外，设 dp</em>{i,j} 为从 (1,1) 到 (i,j) 的路程数，公式 dp_{i,j}=dp_{i-1,j-1}+dp_{i,j-1}，则 dp_{n,n} 即为所求（O(n^2)）。<br>
裸题：<a href="https://www.luogu.com.cn/problem/P1044">栈</a><br>
代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
inline long long exgcd(long long x,long long y,long long &amp;a,long long &amp;b){
    if(y==0){
    	a=1,b=0;
		return x;
	}
    else {
    	long long plok=exgcd(y,x%y,b,a);
    	b-=x/y*a;
    	return plok;
    }
}
long long n,p=999911659,ans=0;
long long s[49],l[49];
inline void cin(long long &amp;x){
    x=0;
    char c=' ';
    bool f=false;
    while((c&lt;'0'||c&gt;'9')&amp;&amp;c!='-')c=getchar();
    if(c=='-'){
        f=true;
        c=getchar();
    }
    while(c&lt;='9'&amp;&amp;c&gt;='0'){
        x=x*10+c-'0';
        c=getchar();
    }
    if(f)x=-x;
}
int main(){
    cin(n);
    s[0]=1;
    if(n==1){
        printf(&quot;1\n&quot;);
        return 0;
    }
    for(int i=1;i&lt;=2*n;i++){
        s[i]=s[i-1]*i%p;
    }
    long long y;
    exgcd(s[2*n],p,l[2*n],y);
    l[2*n]=(l[2*n]%p+p)%p;
    for(int i=2*n-1;i&gt;=1;i--){
        l[i]=l[i+1]*(i+1)%p;
    }
    printf(&quot;%lld\n&quot;,(p+s[2*n]*l[n]%p*l[n]%p-s[2*n]*l[n-1]%p*l[n+1]%p)%p);
    return 0;
}

#include&lt;cstdio&gt;
using namespace std;
int n,dp[20][20];
int main(){
    scanf(&quot;%d&quot;,&amp;n);
    dp[0][0]=1;
    for(int i=1;i&lt;=n;i++){
        for(int j=0;j&lt;=i;j++){
            dp[i][j]=dp[i][j-1];//出栈
            if(j&lt;i)dp[i][j]+=dp[i-1][j];//入栈
        }
    }
    printf(&quot;%d\n&quot;,dp[n][n]);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数论]]></title>
        <id>https://NuclearPasta3579.github.io/post/shu-lun/</id>
        <link href="https://NuclearPasta3579.github.io/post/shu-lun/">
        </link>
        <updated>2023-08-08T09:09:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1素数筛">1.素数筛</h1>
<p>素数筛只通过一种方法得到 2 到 n 范围类的质数合数情况。<br>
常见方法有埃氏筛和欧拉筛。<br>
这里只讲欧拉筛，欧拉筛的操作时从小到大遍历每个数，对于每个 x，和一个小于它的素数 p，排除 x \cdot p。<br>
理论上，这种方法会使对应范围内每个合数被筛一次，故为 O(n)。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
int n,q,k,ss[6000001],cnt=0;
bool isprime[60000001];
inline void cin(register int &amp;x){
    x=0;
    bool f=false;
    char c=' ';
    while((c&lt;'0'||c&gt;'9')&amp;&amp;c!='-')c=getchar();
    if(c=='-'){
        f=true;
        c=getchar();
    }
    while(c&lt;='9'&amp;&amp;c&gt;='0'){
        x=x*10+c-'0';
        c=getchar();
    }
    if(f)x=-x;
}
int main(){
    cin(n),cin(q);
    for(register int i=2;i&lt;=n;i++){
        if(!isprime[i])ss[++cnt]=i;
        for(register int j=1;j&lt;=cnt&amp;&amp;i*ss[j]&lt;=n;j++){
            isprime[i*ss[j]]=true;
        }
    }
    for(register int i=1;i&lt;=q;i++){
        cin(k);
        printf(&quot;%d\n&quot;,ss[k]);
    }
    return 0;
}
</code></pre>
<p>素数筛可以用来递推求部分函数的值，如欧拉函数：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
long long n,k,ss[1000001],cnt=0,ans,phi[10000001],r;
int main(){
    scanf(&quot;%lld&quot;,&amp;n);
    phi[1]=1;
    for(long long i=2;i&lt;=n;i++){
        if(phi[i]==0){ss[++cnt]=i;phi[i]=i-1;}
        for(long long j=1;j&lt;=cnt&amp;&amp;i*ss[j]&lt;=n;j++){
            if(i%ss[j]==0){
                phi[i*ss[j]]=phi[i]*ss[j];
            }
            else phi[i*ss[j]]=phi[i]*(ss[j]-1);
        }
    }
    return 0;
}
</code></pre>
<p>例题:<a href="https://www.luogu.com.cn/problem/P2568">P2568 GCD</a><br>
这道题 n \le 10^7,要求每一步复杂度不得超过 O(n)，首先对于一个整数 x，与它互质的整数有 \phi(X) 个（用欧拉筛递推求解），设其中一个为 y，对于一个素数 p 使 x \cdot p \le n，有 (x \cdot p,y \cdot p),(y \cdot p,x \cdot p) 符合要求，其中对应 p 的个数可以用<a href="https://nuclearpasta3579.github.io/post/shuang-zhi-zhen/">双指针</a>来求。<br>
注意对于每个质数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">p\le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>p</mi><mo separator="true">,</mo><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(p,p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span> 会被多算一次。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
long long n,k,ss[1000001],cnt=0,ans,phi[10000001],r;
int main(){
    scanf(&quot;%lld&quot;,&amp;n);
    phi[1]=1;
    for(long long i=2;i&lt;=n;i++){
        if(phi[i]==0){ss[++cnt]=i;phi[i]=i-1;}
        for(long long j=1;j&lt;=cnt&amp;&amp;i*ss[j]&lt;=n;j++){
            if(i%ss[j]==0){
                phi[i*ss[j]]=phi[i]*ss[j];
            }
            else phi[i*ss[j]]=phi[i]*(ss[j]-1);
        }
    }
    r=cnt;
    for(long long i=1;i&lt;=n;i++){
        while(r&gt;0&amp;&amp;ss[r]*i&gt;n)r--;
        if(r==0)break;
        ans+=2*r*phi[i];
    }
    ans-=cnt;
    printf(&quot;%lld&quot;,ans);
    return 0;
}
</code></pre>
<h1 id="2乘法逆元">2.乘法逆元</h1>
<p>若 a \cdot b\equiv 1(\mod p)，则称 b 为 a 摸 n 的逆元，即 b=a<sup>{-1}，a</sup>{-1}的求法很多，但只有 \gcd(a,p)=1 时存在：</p>
<ol>
<li>扩展欧几里得求使 a \cdot x + p \cdot k=1 的最小的正整数 x，则  x 即为所求。</li>
<li>根据欧拉定理 a^{\phi(p)}\equiv 1(\mod p)，得 a^{\phi(p)-1}\mod p 即为所求。</li>
<li>以 (p-p/i)*{(p%i)}^{-1} 为公式进行递推。</li>
<li>求前缀乘积，解所有数乘积的逆元后往前推。</li>
</ol>
<p>代码分别如下：</p>
<pre><code class="language-cpp">//扩欧解：
#include&lt;cstdio&gt;
using namespace std;
inline long long exgcd(long long x,long long y,long long &amp;a,long long &amp;b){
    if(y==0){
    	a=1,b=0;
		return x;
	}
    else {
    	long long plok=exgcd(y,x%y,b,a);
    	b-=x/y*a;
    	return plok;
    }
}
long long a,b,x,y;
int main(){
	scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);
	exgcd(a,b,x,y);
	long long l=-1,r=3e9;
	while(r-l&gt;1){
		long long mid=(l+r+1)/2;
		if(mid*b+x&lt;0)l=mid;
		else r=mid;
	}
	printf(&quot;%lld\n&quot;,x+r*b);
	return 0;
} 
//欧拉定理解
#include&lt;cstdio&gt;
#define int long long
using namespace std;
int a,b,p;
inline int fast_times(int x,int y){
    if(x==0)return 0;
    else if(y==0)return 1;
    else if(y==1)return x%p;
    int t=fast_times(x%p,y/2)%p;
    if(y%2==0)return 1ll*(t%p)*(t%p)%p;
    else return 1ll*((t%p)*(t%p)%p)*(x%p)%p;
}
inline long long phi(long long n){
    long long ans=n;
    for(long long i=2;1ll*i*i&lt;=n;i++){
        if(n%i==0){
            ans=ans/i*(i-1);
            while(n%i==0)n/=i;
        }
    }
    if(n&gt;1)ans=ans/n*(n-1);
    return ans;
}
signed main(){
    scanf(&quot;%lld%lld&quot;,&amp;a,&amp;p);
    printf(&quot;%lld&quot;,fast_times(a%p,phi(p)-1));
    return 0;
}
//递推解
#include&lt;cstdio&gt;
using namespace std;
int ans[3000001],n,p;
int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;p);
    ans[1]=1;
    putchar('1');
    putchar('\n');
    for(int i=2;i&lt;=n;i++){
        ans[i]=1ll*(p-p/i)*ans[p%i]%p;
        printf(&quot;%d\n&quot;,ans[i]);
    }
}
//解法4
#include&lt;cstdio&gt;
using namespace std;
inline long long exgcd(long long x,long long y,long long &amp;a,long long &amp;b){
    if(y==0){
    	a=1,b=0;
		return x;
	}
    else {
    	long long plok=exgcd(y,x%y,b,a);
    	b-=x/y*a;
    	return plok;
    }
}
long long n,p,k,ans=0;
long long s[5000009],l[5000009],a[5000009];
inline void cin(long long &amp;x){
    x=0;
    char c=' ';
    bool f=false;
    while((c&lt;'0'||c&gt;'9')&amp;&amp;c!='-')c=getchar();
    if(c=='-'){
        f=true;
        c=getchar();
    }
    while(c&lt;='9'&amp;&amp;c&gt;='0'){
        x=x*10+c-'0';
        c=getchar();
    }
    if(f)x=-x;
}
int main(){
    cin(n),cin(p),cin(k);
    s[0]=1;
    for(int i=1;i&lt;=n;i++){
        cin(a[i]);
        s[i]=s[i-1]*a[i]%p;
    }
    long long y;
    exgcd(s[n],p,l[n],y);
    l[n]=(l[n]%p+p)%p;
    for(int i=n-1;i&gt;=1;i--){
        l[i]=l[i+1]*a[i+1]%p;
    }
    long long t=1;
    for(int i=1;i&lt;=n;i++){
        t=k*t%p;
        ans=(ans+t%p*l[i]%p*s[i-1]%p)%p;
    }
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
<h1 id="3bsgs">3.BSGS</h1>
<p>对于三个整数 b,n,p，若 \gcd(b,p)=1 则可用 <code>BSGS</code> 解使 b^l\equiv n (\mod p) 的最小的 l。<br>
<code>BSGS</code> 的做法是：</p>
<ul>
<li>处理所有 n \cdot b^l,l\le \sqrt p，求对应余数的最大指数。</li>
<li>接下来枚举 b^{(t\cdot \sqrt p)}，如果他与 n\cdot b^a（a 最大且 a \le \sqrt p），t\cdot \sqrt p-a 即为所求。<br>
时间复杂度：O(\sqrt p)$<br>
代码：</li>
</ul>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
using namespace std;
long long n,b,p;
long long tcp,md,ntc;
template&lt;typename T&gt;
inline T fast_times(T x,T y){
    if(x==0)return 0;
    else if(y==0)return 1;
    else if(y==1)return x%p;
    T t=fast_times(x%p,y/2)%p;
    if(y%2==0)return 1ll*(t%p)*(t%p)%p;
    else return 1ll*((t%p)*(t%p)%p)*(x%p)%p;
}
struct in{
    long long val,ans;
};
const long long moder=3732971;
vector&lt;in&gt;v[moder];
int main(){
    scanf(&quot;%lld%lld%lld&quot;,&amp;p,&amp;b,&amp;n);
    md=sqrt(p);
    tcp=fast_times(b,md);
    ntc=n%p;
    for(int i=1;i&lt;=md;i++){
        ntc=ntc*b%p;
        bool op=false;
        for(int j=0;j&lt;v[ntc%moder].size();j++){
            if(v[ntc%moder][j].val==ntc){v[ntc%moder][j].ans=i;op=true;break;}
        }
        if(!op)v[ntc%moder].push_back(in{ntc,i});
    }
    bool flg=false;
    long long lp=tcp;
    for(int i=1;i*md-md&lt;=p;i++){
        for(int j=0;j&lt;v[lp%moder].size();j++){
            if(v[lp%moder][j].val==lp){flg=true;printf(&quot;%lld\n&quot;,i*md-v[lp%moder][j].ans);break;}
        }
        if(flg)break;
        lp=lp*tcp%p;
    }
    if(!flg)printf(&quot;no solution\n&quot;);
    return 0;
}
</code></pre>
<h1 id="4阶与原根">4.阶与原根</h1>
<p>阶指最小的 l 使 b^l\equiv 1(\mod p),\gcd(b,p)=1，若 n=\phi (p)，则 b 为 p 的原根。<br>
我们易于证明 n | \phi(p)，可用试除法求阶，复杂度 O(\sqrt p + \log^2 p)</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#define int long long
using namespace std;
inline int phi(int n){
    int ans=n;
    for(int i=2;i*i&lt;=n;i++){
        if(n%i==0){
            ans=ans/i*(i-1);
            while(n%i==0)n/=i;
        }
    }
    if(n&gt;1)ans=ans/n*(n-1);
    return ans;
}
int n,p,l;
inline int fast_times(int x,int y){
    if(x==0)return 0;
    else if(y==0)return 1;
    else if(y==1)return x%p;
    int t=fast_times(x%p,y/2)%p;
    if(y%2==0)return 1ll*(t%p)*(t%p)%p;
    else return 1ll*((t%p)*(t%p)%p)*(x%p)%p;
}
vector&lt;int&gt;a;
inline void find(int u){
    for(int i=2;i*i&lt;=u;i++){
        if(u%i==0){
            a.push_back(i);
            while(u%i==0)u/=i;
        }
    }
    if(u&gt;1)a.push_back(u);
}
signed main(){
    scanf(&quot;%lld %lld&quot;,&amp;n,&amp;p);
    l=phi(p);
    find(l);
    for(int i=0;i&lt;a.size();i++){
        while(l%a[i]==0&amp;&amp;fast_times(n%p,l/a[i])==1){
            l/=a[i];
        }
    }
    printf(&quot;%lld&quot;,l);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树形DP]]></title>
        <id>https://NuclearPasta3579.github.io/post/shu-xing-dp/</id>
        <link href="https://NuclearPasta3579.github.io/post/shu-xing-dp/">
        </link>
        <updated>2023-08-08T08:47:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1树形dp">1.树形DP</h1>
<p>指在树上进行动态规划。	    	<br>
常见转移方式：</p>
<ol>
<li>父节点转移到子节点；</li>
<li>子节点转移到父节点。</li>
</ol>
<p>例如：</p>
<ul>
<li>在计算点的深度时，转移方程为 dp_v=dp_{fa}+len 是父节点转移到子节点的 <code>DP</code>。</li>
<li>在计算点的子树权值时，转移方程为 dp_v=cost_v+\sum dp_{son} 是子节点转移到父节点的 <code>DP</code>。</li>
</ul>
<h1 id="2换根思想">2.换根思想</h1>
<p>换根思想是解决部分树上问题的常用思想。<br>
针对询问从每个点出发时的贡献时，先解决一个点的贡献，再从这个点开始递推。<br>
递推时，考虑根节点从父节点换成这个节点时，贡献的变化。<br>
例：<a href="https://www.luogu.com.cn/problem/P2986">[USACO10MAR] Great Cow Gathering G</a><br>
解决一个点的贡献：<br>
dp_v=\sum dp_{son}+size_{son}<br>
当根从父节点 fa 到子节点时，先都到父节点，再去子节点，减掉子节点子树上点多走两段，得 dp_v=dp_{fa}+size_{fa}-2\times size_v。<br>
代码：</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
long long n,ans2=1e14,s[500007],c[500007],u,v,w,k[500007];
vector&lt;long long&gt;e[500007];
vector&lt;long long&gt;g[500007];
long long srh1(long long nk,long long f){
    c[nk]=0;
    if(e[nk].size()==1&amp;&amp;nk!=1)return 0;
    for(long long i=0;i&lt;e[nk].size();i++){
        if(e[nk][i]!=f)c[nk]+=srh1(e[nk][i],nk)+s[e[nk][i]]*g[nk][i];
    }
    return c[nk];
}
long long srh2(long long nk,long long f){
    s[nk]=k[nk];
    for(long long i=0;i&lt;e[nk].size();i++){
        if(e[nk][i]!=f)s[nk]+=srh2(e[nk][i],nk);
    }
    return s[nk];
}
void srh3(long long nk,long long f,long long len){
    if(nk==1){
        goto flknj;
    }
    c[nk]=c[f]+(s[f]-2*s[nk])*len;
    s[nk]=s[f];
    flknj:
    if(c[nk]&lt;ans2){
        ans2=c[nk];
    }
    for(long long i=0;i&lt;e[nk].size();i++){
        if(e[nk][i]!=f)srh3(e[nk][i],nk,g[nk][i]);
    }
    
}
int main(){
    scanf(&quot;%lld&quot;,&amp;n);
    for(long long i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;k[i]);
    for(long long i=1;i&lt;=n-1;i++){
        scanf(&quot;%lld%lld%lld&quot;,&amp;u,&amp;v,&amp;w);
        e[u].push_back(v);
        e[v].push_back(u);
        g[u].push_back(w);
        g[v].push_back(w);
    }
    s[1]=srh2(1,0);
    c[1]=srh1(1,0);
    srh3(1,0,0);
    printf(&quot;%lld&quot;,ans2);
    return 0;
}
</code></pre>
<h1 id="3基环树">3.基环树</h1>
<p>基环树指只有一个环的无向图，解决基环树上的问题时通常从树上对于同一个问题的解法推导而来。<br>
比如在解决<a href="https://www.luogu.com.cn/problem/P1453">城市环路</a>这道题时，先考虑如何在树上解决该问题，对应问题为<a href="https://www.luogu.com.cn/problem/P1352">没有上司的舞会</a>。<br>
对于基环树来说，首先选择环上的一条边，当这条边不被考虑时，就是树上的问题，考虑后，边的两端至少有一端不选。<br>
代码：</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt; 
using namespace std;
vector&lt;int&gt;e[100009],g[100009];
bool tree[100009],vis[100009],flg,incir[100009],tp[100009];
int n,dp[100009][2],p[100009];
double k;
int ans;
inline void sp_srh(int nk){
    vis[nk]=true;
    for(int i=0;i&lt;e[nk].size();i++){
        if(!vis[e[nk][i]]){
            tree[g[nk][i]]=true;
            sp_srh(e[nk][i]);
            if(flg)return;
        }
        else if(!tree[g[nk][i]]){
            tp[g[nk][i]]=true;
            return;
        }
    }
}
inline void srh(int nk,int l){
    dp[nk][0]=0,dp[nk][1]=p[nk];
    for(int i=0;i&lt;e[nk].size();i++){
        if(!tp[g[nk][i]]&amp;&amp;e[nk][i]!=l){
            srh(e[nk][i],nk);
            dp[nk][0]+=max(dp[e[nk][i]][0],dp[e[nk][i]][1]);
            dp[nk][1]+=dp[e[nk][i]][0];
        }
    }
}
int main(){
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;p[i]);
    for(int i=1;i&lt;=n;i++){
        int u,v;
        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
        e[u].push_back(v);
        e[v].push_back(u);
        g[u].push_back(i);
        g[v].push_back(i);
    }
    scanf(&quot;%lf&quot;,&amp;k);
    sp_srh(0);
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;g[i].size();j++){
            if(tp[g[i][j]]){
                srh(i,n);
                ans=dp[i][0];
                srh(e[i][j],n);
                ans=max(ans,dp[e[i][j]][0]);
                goto answ;
            }
        }
    }
    answ:
    printf(&quot;%.1lf&quot;,k*ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搜索优化]]></title>
        <id>https://NuclearPasta3579.github.io/post/sou-suo-you-hua/</id>
        <link href="https://NuclearPasta3579.github.io/post/sou-suo-you-hua/">
        </link>
        <updated>2023-08-08T08:21:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="搜索">搜索</h1>
<p>搜索分为深度优先搜索和广度优先搜索，其主要的区别是：</p>
<ul>
<li>深度优先搜索会不断枚举下去，直到无法再扩展才回溯。</li>
<li>广度优先搜索会优先依次扩展对应值最小的状态。</li>
</ul>
<p>如下是深搜的例子：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
int n,k,ans;
void srh(int m,int t,int l){
    if(t==k){
        ans++;
        return ;
    }
    for(int i=l;i&lt;=m/(k-t+1);++i){
        srh(m-i,t+1,i);
    }
}
int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
    srh(n,1,1);
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
</code></pre>
<p>如下是广搜的例子：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int n,a,b,k[207],lt[207];
int st[207],*begin=&amp;st[1],*end=&amp;st[0];
bool vis[207];
inline int bfs(int start,int departure){
    memset(lt,-1,sizeof(lt));
    lt[start]=0;
    end++;
    *end=start;
    while(end&gt;=begin){
        int d=*begin;
        begin++;
        vis[d]=true;
        if(d+k[d]&lt;=n&amp;&amp;!vis[d+k[d]]){
            lt[d+k[d]]=lt[d]+1;
            end++;
            *end=d+k[d];
            vis[d+k[d]]=true;
            if(d+k[d]==departure)break;
        }
        if(d&gt;k[d]&amp;&amp;!vis[d-k[d]]){
            lt[d-k[d]]=lt[d]+1;
            end++;
            *end=d-k[d];
            vis[d-k[d]]=true;
            if(d-k[d]==departure)break;
        }
    }
    return lt[departure];
}
int main(){
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;a,&amp;b);
    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;k[i]);
    printf(&quot;%d\n&quot;,bfs(a,b));
    return 0;
}
</code></pre>
<p>广搜之前已经讲过，具体看<a href="https://nuclearpasta3579.github.io/post/guang-sou">这里</a>。<br>
而后续的优化将会重点针对深搜。</p>
<h1 id="优化1剪枝">优化1：剪枝</h1>
<p>指的是减掉经判定无法更新答案的状态。<br>
比如说在<a href="https://www.luogu.com.cn/problem/P1025">数的划分</a>中，我们易得第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 与上一个值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>，在应使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>≤</mo><mi>x</mi><mo>≤</mo><mi>m</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>k</mi><mo>−</mo><mi>t</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">p \leq x \leq m/(k-t+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，代码如下：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
int n,k,ans;
void srh(int m,int t,int l){
    if(t==k){
        ans++;
        return ;
    }
    for(int i=l;i&lt;=m/(k-t+1);++i){
        srh(m-i,t+1,i);
    }
}
int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
    srh(n,1,1);
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
</code></pre>
<h1 id="优化2折半搜索">优化2：折半搜索</h1>
<p>我们可以先枚举前一半，再枚举后一半，组合在一起，这就是折半搜索，它可以使搜索的时间复杂度由原先的 \operatorname{O}(l) 变为 \operatorname{O}(\sqrt l)。<br>
<a href="https://www.luogu.com.cn/problem/P4799">例子</a><br>
这道题直接搜索显然会 <code>T</code>，但折半搜索不会，合并会用到<a href="https://nuclearpasta3579.github.io/post/shuang-zhi-zhen/">双指针</a>，代码如下：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define int long long
using namespace std;
int k;
struct mode{
    int sum,mod; 
};
bool cmp(mode x,mode y){
    return x.sum&lt;y.sum;
}
bool change(mode x,mode y){
    return x.sum+y.sum&gt;k;
}
int n,a[41],sta=-1,stb=-1,ans;
mode lf[(1&lt;&lt;20)],rt[(1&lt;&lt;20)];
inline void srh(int lim,int x,int now,int sum,bool flg){
    if(x==lim){
        if(!flg)
            lf[++sta]={sum,now};
        else
            rt[++stb]={sum,now};
        return ;
    }
    if(sum+a[x]&lt;=k)srh(lim,x+1,now|(1&lt;&lt;x),sum+a[x],flg);
    srh(lim,x+1,now,sum,flg);
}
signed main(){
    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);
    for(int i=0;i&lt;n;i++)scanf(&quot;%lld&quot;,&amp;a[i]);
    srh(n/2,0,0,0,true);
    srh(n,n/2,0,0,false);
    sort(lf,lf+sta+1,cmp);
    sort(rt,rt+stb+1,cmp);
    int lp=stb;
    for(int i=0;i&lt;=sta;i++){
        while(lp&gt;=0&amp;&amp;change(lf[i],rt[lp]))lp--;
        if(lp==-1)break;
        int u=lp;
        ans+=u+1;
    }
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
<h1 id="3启发式搜索和a">3.启发式搜索和A*</h1>
<p>启发式搜索指的是对于每个状态，用一种方法求出它的预估值，如果目前的步数加上预估值没有优于目前的答案，则结束这个状态。<br>
<code>A*</code>已经讲过，详情见<a href="https://nuclearpasta3579.github.io/post/a">这里</a>,<br>
题目：<a href="https://www.luogu.com.cn/problem/P2324">P2324 [SCOI2005]骑士精神</a><br>
这道题只需要以不在应在的位置的棋子数为估值进行启发式搜索即可。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int departure[5][5]={{1,1,1,1,1},{0,1,1,1,1},{0,0,-1,1,1},{0,0,0,0,1},{0,0,0,0,0}};
int now[5][5],blankx,blanky,ans=16,dx[8]={2,2,1,1,-1,-1,-2,-2},dy[8]={1,-1,2,-2,2,-2,1,-1};
int t;
inline int ycl(){
    int cnt=0;
    for(int i=0;i&lt;5;i++){
        for(int j=0;j&lt;5;j++){
            if(now[i][j]!=-1&amp;&amp;now[i][j]!=departure[i][j])cnt++;
        }
    }
    return cnt;
}
inline void srh(int x){
    if(ycl()+x&gt;=ans)return;
    if(ycl()==0){
        ans=x;
        return ;
    }
    for(int i=0;i&lt;8;i++){
        int nx=blankx+dx[i],ny=blanky+dy[i];
        if(nx&lt;0||nx&gt;4||ny&lt;0||ny&gt;4)continue;
        int lx=blankx,ly=blanky;
        swap(now[blankx][blanky],now[nx][ny]);
        blankx=nx,blanky=ny;
        srh(x+1);
        swap(now[lx][ly],now[nx][ny]);
        blankx=lx,blanky=ly;
    }
}
int main(){
    scanf(&quot;%d&quot;,&amp;t);
    cin.tie(0),cout.tie(0);
    while(t--){
        for(int i=0;i&lt;5;i++){
            for(int j=0;j&lt;5;j++){
                char a;
                cin&gt;&gt;a;
                if(a!='*')now[i][j]=a-'0';
                else {now[i][j]=-1;blankx=i,blanky=j;}
            }
        }
        ans=16;
        srh(0);
        printf(&quot;%d\n&quot;,ans==16?-1:ans);
    }
    return 0;
}
</code></pre>
<h1 id="4-迭代加深">4、迭代加深</h1>
<p>迭代加深是指当使用深搜时出现层数过多的问题，对于深搜的优化，其逐步增加枚举的最大层数，当存在结果是答案极为对应的最大层数。<br>
迭代加深可以和启发式搜索结合在一起，即为迭代加深启发式搜索（<code>IDA*</code>），指当层数加估值大于当前最大层数时提前结束。<br>
例如:</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/UVA529">这道题</a>需进行迭代加深，而不需要算估值：</li>
</ul>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
int flag,ans[10009],t,n,m;
void dfs(int x,int lim){
	if(ans[x-1]==n){
		flag=1;
		return;
	}
	if(flag==1||x&gt;=lim)return ;
	for(int i=0;i&lt;x;i++)
		for(int j=i;j&lt;x;j++){
			if(ans[i]+ans[j]&gt;n)break;
			if(ans[i]+ans[j]&lt;=ans[x-1]||m-x&lt;log2((n+ans[i]+ans[j]-1)/(ans[i]+ans[j])))continue;
			ans[x]=ans[i]+ans[j];
			dfs(x+1,lim);
            if(flag==1)return;
		}
}
int main()
{
	while(true){
		scanf(&quot;%d&quot;,&amp;n);
		if(n==0)break;
		if (n==1){
			printf(&quot;1\n&quot;);
			continue;
		}
		flag=0,m=0;
		while(flag==0&amp;&amp;m&lt;n){
			ans[0]=1;
			m++;
			dfs(1,m);
		}
		for(int i=0;i&lt;m-1;i++)printf(&quot;%d &quot;,ans[i]);
		printf(&quot;%d\n&quot;,ans[m-1]);
	}
    return 0;
}
</code></pre>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2534">这道</a>则需要考虑估值：</li>
</ul>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
int n,a[20],s[200],tp[20],cnt=0;
bool flag=false;
inline int seen(int stk[]){
    int ant=0;
    for(int i=1;i&lt;=n;i++){
        if(abs(stk[i]-stk[i+1])!=1)ant++;
    }
    return ant;
}
inline bool cmp(int x,int y){
    return a[x]&lt;a[y];
}
inline void srh(int x,int st[],int lim,int ktv){
    //printf(&quot;%d\n&quot;,x);
    //for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,st[i]);
    //printf(&quot;\n%d\n&quot;,lim);
    int tpn=seen(st);
    if(x+tpn&gt;lim||flag)return;
    //printf(&quot;%d stlk\n\n&quot;,tpn);
    if(tpn==0){
        flag=true;
        return;
    }
    for(int i=n;i&gt;=2;i--){
        if(st[i+1]-st[i]==1||i==ktv)continue;
        for(int j=1;j*2&lt;=i;j++){
            int id=st[j];
            st[j]=st[i+1-j];
            st[i+1-j]=id;
        }
        srh(x+1,st,lim,i);
        for(int j=1;j*2&lt;=i;j++){
            int id=st[j];
            st[j]=st[i+1-j];
            st[i+1-j]=id;
        }
    }
}
int main(){
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%d&quot;,&amp;a[i]);
        tp[i]=i;
    }
    sort(tp+1,tp+n+1,cmp);
    for(int i=1;i&lt;=n;i++){
        s[tp[i]]=i;
    }
    s[n+1]=n+1;
    //for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,s[i]);
    //printf(&quot;\n&quot;);
    int i=0;
    while(true){
        srh(0,s,i,1);
        if(flag==true){
            printf(&quot;%d&quot;,i);
            return 0;
        }
        else i++;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单调性优化]]></title>
        <id>https://NuclearPasta3579.github.io/post/dan-diao-xing-you-hua/</id>
        <link href="https://NuclearPasta3579.github.io/post/dan-diao-xing-you-hua/">
        </link>
        <updated>2023-08-08T08:15:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-单调性优化">1、单调性优化</h1>
<p>单调性优化是一种用于优化<strong>动态规划</strong>的算法，对于一个转移变量 dp_{i},以及转移函数 f_{i,j}，存在函数 g_{i,j}，使得对于 \forall i&lt;j&lt;k ,dp_i+g_{i,k}&lt;dp_j+g_{j,k}\iff dp_i+f_{i,k}&lt;dp_j+f_{j,k} 或 \forall i&lt;j&lt;k ,dp_i+g_{i,k}&gt;dp_j+g_{j,k}\iff dp_i+f_{i,k}&gt;dp_j+f_{j,k}，则可以用单调性优化线性求解。</p>
<h1 id="2-单调性优化的应用">2、单调性优化的应用</h1>
<h2 id="1-双指针">1、 双指针</h2>
<p>双指针是利用单调性优化的一种算法，详情在<a href="https://nuclearpasta3579.github.io/post/shuang-zhi-zhen/">这里</a></p>
<h2 id="2-单调栈与单调队列">2、单调栈与单调队列</h2>
<p>单调栈用于求最近的优于一个变量的另一个变量，其在入栈时会剔除所有在栈顶且比目前变量优先级弱的变量，然后再加入变量，通常来说，单调栈运行时，栈顶剔除变量后先记录答案，即剔除后余下的元素栈顶，然后再进栈。<br>
代码：</p>
<pre><code class="language-cpp">//st[i]为单调栈，os[i]为栈内元素下标，ans[i]为答案，sz为栈顶下标,op为加入元素，pl为对应下标,这里展示的是单调递减的单调栈。
while(sz&gt;=0&amp;&amp;st[sz]&lt;=op)sz--;//剔除
if(sz&gt;=0)ans[pl]=os[sz];//记录答案
sz++;
st[sz]=op;
os[sz]=pl;//入栈
</code></pre>
<p>例题：<a href="https://www.luogu.com.cn/problem/P1823">[COI2007] Patrik 音乐会的等待</a><br>
解法：<br>
根据题意，单调栈中的元素中最近的大于该元素的结果对答案有贡献，所以先二分求答案，在进行入栈操作可以解决问题。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
int n,a[500001];
long long ansl;
int top=0,ins[500001];
inline void cin(int &amp;x){
    x=0;
    bool f=false;
    char c;
    while((c&lt;'0'||c&gt;'9')&amp;&amp;c!='-')c=getchar();
    if(c=='-'){
    	f=true;
    	c=getchar();
    }
    while(c&lt;='9'&amp;&amp;c&gt;='0'){
        x=x*10+c-'0';
        c=getchar();
    }
    if(f)x=-x;
}
inline void cout(long long u){
    if(u&gt;=10)cout(u/10);
    putchar(u%10+'0');
}
signed main(){
    cin(n);
    for(int i=1;i&lt;=n;i++){
        cin(a[i]);
        int l=1,r=top+1;
        while(r-1&gt;l){
        	int mid=(l+r)/2;
        	if(a[ins[mid]]&gt;a[i])l=mid;
        	else r=mid;
		}
		ansl+=top-l+1;
        while(top&gt;0&amp;&amp;a[ins[top]]&lt;a[i])top--;
        ins[++top]=i;
    }
    cout(ansl);
    return 0;
}

</code></pre>
<p>单调队列则用来求无需从前面插入时静态区间最优值，其余单调栈的区别是：</p>
<ol>
<li>它的答案对应队首而非栈顶；</li>
<li>需要在前面将范围以外的元素出队<br>
代码：</li>
</ol>
<pre><code class="language-cpp">class myownqueue_max{
    private: int q1[2001],qz1[2001],head=1,tail=0;
    public: void clear(){
        head=1;
        tail=0;
    }
    int front(){
        if(tail&lt;head)return 0;
        else return q1[head];
    }
    void push(int number,int place){
        while(tail&gt;=head&amp;&amp;q1[tail]&lt;=number)tail--;
        tail=tail+1;
        q1[tail]=number;
        qz1[tail]=place;
    }
    void kill(int end){
        while(qz1[head]&lt;end)head++;
    }
};
class myownqueue_min{
    private: int q2[2001],qz2[2001],head=1,tail=0;
    public: void clear(){
        head=1;
        tail=0;
    }
    int front(){
        if(tail&lt;head)return 0;
        else return q2[head];
    }
    void push(int number,int place){
        while(tail&gt;=head&amp;&amp;q2[tail]&gt;=number)tail--;
        tail=tail+1;
        q2[tail]=number;
        qz2[tail]=place;
    }
    void kill(int end){
        while(qz2[head]&lt;end)head++;
    }
};
</code></pre>
<p>例题：<a href="https://www.luogu.com.cn/problem/P2216">[HAOI2007]理想的正方形</a><br>
解法：先记录其中一维的结果，再用于推另一维的结果。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#define int long long
using namespace std;
int a,b,n,num[1009][1009],most[1009][1009],least[1009][1009],ans=0x3f3f3f3f;
class myownqueue_max{
    private: int q1[2001],qz1[2001],head=1,tail=0;
    public: void clear(){
        head=1;
        tail=0;
    }
    int front(){
        if(tail&lt;head)return 0;
        else return q1[head];
    }
    void push(int number,int place){
        while(tail&gt;=head&amp;&amp;q1[tail]&lt;=number)tail--;
        tail=tail+1;
        q1[tail]=number;
        qz1[tail]=place;
    }
    void kill(int end){
        while(qz1[head]&lt;end&amp;&amp;head&lt;=tail)head++;
    }
};
class myownqueue_min{
    private: int q2[2001],qz2[2001],head=1,tail=0;
    public: void clear(){
        head=1;
        tail=0;
    }
    int front(){
        if(tail&lt;head)return 0;
        else return q2[head];
    }
    void push(int number,int place){
        while(tail&gt;=head&amp;&amp;q2[tail]&gt;=number)tail--;
        tail=tail+1;
        q2[tail]=number;
        qz2[tail]=place;
    }
    void kill(int end){
        while(qz2[head]&lt;end&amp;&amp;head&lt;=tail)head++;
    }
};
inline int min(int x,int y){
    if(x&gt;=y)return y;
    else return x;
}
myownqueue_max qmax;
myownqueue_min qmin;
inline void cin(int &amp;x){
    x=0;
    bool f=false;
    char c;
    while((c&lt;'0'||c&gt;'9')&amp;&amp;c!='-')c=getchar();
    if(c=='-'){
    	f=true;
    	c=getchar();
    }
    while(c&lt;='9'&amp;&amp;c&gt;='0'){
        x=x*10+c-'0';
        c=getchar();
    }
    if(f)x=-x;
}
inline void cout(int u){
    if(u&gt;=10)cout(u/10);
    putchar(u%10+'0');
}
signed main(){
    cin(a),cin(b),cin(n);
    for(int i=1;i&lt;=a;i++)
        for(int j=1;j&lt;=b;j++)
            cin(num[i][j]);
    for(int i=1;i&lt;=b;i++){
        qmax.clear();
        qmin.clear();
        for(int j=1;j&lt;=a;j++){
            qmax.push(num[j][i],j);
            qmin.push(num[j][i],j);
            if(j&gt;=n){
                qmax.kill(j-n+1);
                qmin.kill(j-n+1);
                most[j-n+1][i]=qmax.front();
                least[j-n+1][i]=qmin.front();
            }
        }
    }
    for(int i=1;i&lt;=a-n+1;i++){
        qmax.clear();
        qmin.clear();
        for(int j=1;j&lt;=b;j++){
            qmax.push(most[i][j],j);
            qmin.push(least[i][j],j);
            if(j&gt;=n){
                qmax.kill(j-n+1);
                qmin.kill(j-n+1);
                ans=min(ans,qmax.front()-qmin.front());
            }
        }
    }
    cout(ans);
    return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/training/288486">练习</a></p>
<h2 id="3-多重背包">3、多重背包</h2>
<p>利用单调性优化可以将多重背包问题的复杂度降为 O(nW)，其在枚举每一个物品时，枚举其模物品价值余数和商，对于每个物品和模数的情况，用单调队列维护 dp_{i,j+k \times w_i}-k \times v_i，用来更新答案。<br>
代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int n, v[10005], w[10005], m[10005], W;
int dp[10005][1005];

int main() {
	cin &gt;&gt; n &gt;&gt; W;
	for (int i = 1; i &lt;= n; i++) {
		cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; m[i];
	}
	memset(dp, ~0x3f, sizeof(dp));
	dp[0][0] = 0;
	for (int i = 1; i &lt;= n; i++) {
		for (int j = 0; j &lt; w[i]; j++) {
			deque&lt;int&gt;q;
			for (int k = 0; k * w[i] + j &lt;= W; k++) {
				while (!q.empty() &amp;&amp; dp[i - 1][j + k * w[i]] - k * v[i] &gt;= dp[i - 1][j + q.back()*w[i]] - q.back()*v[i])
					q.pop_back();
				if (!q.empty() &amp;&amp; k - q.front() &gt; m[i])
					q.pop_front();
				q.push_back(k);
				dp[i][k * w[i] + j] = dp[i - 1][j + q.front() * w[i]] + (k - q.front()) * v[i];
			}
		}
	}
	int ans = 0;
	for (int j = 0; j &lt;= W; j++) {
		ans = max(ans, dp[n][j]);
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
<p>题目：<a href="https://www.luogu.com.cn/problem/P4544">[USACO10NOV]Buying Feed G</a><br>
解法：将商店按位置排序，然后直接进行多重背包，注意额外贡献。<br>
代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int n,W,e;
long long v[505], w[505], m[505],VP[505],WP[505],MP[505],c[505],CP[505];
int TP[505];
long long dp[505][10005];
bool cmp(int i,int j){
	return c[i]&lt;c[j];
}
int main() {
	cin &gt;&gt;W&gt;&gt;e&gt;&gt;n;
	for (int i = 1; i &lt;= n; i++) {
		cin &gt;&gt; c[i] &gt;&gt; m[i] &gt;&gt; v[i];
		TP[i]=i;
		w[i]=1;
	}
	sort(TP+1,TP+n+1,cmp);
	for(int i=1;i&lt;=n;i++){
		int j=TP[i];
		VP[i]=v[j];
		CP[i]=c[j];
		MP[i]=m[j];
	}
	memcpy(v,VP,sizeof(v));
	memcpy(c,CP,sizeof(c));
	memcpy(m,MP,sizeof(m));
	for(int i=0;i&lt;=n;i++){
		for(int j=0;j&lt;=W;j++){
			dp[i][j]=9e18;
		}
	}
	dp[0][0] = 0;
	for (int i = 1; i &lt;= n; i++) {
		for (int j = 0; j &lt; w[i]; j++) {
			deque&lt;long long&gt;q;
			long long u=c[i]-c[i-1];
			for (int k = 0; k * w[i] + j &lt;= W; k++) {
				while (!q.empty() &amp;&amp; dp[i - 1][j + k * w[i]] - k * v[i]+(j + k * w[i])*(j + k * w[i])*u &lt;= dp[i - 1][j + q.back()*w[i]] - q.back()*v[i]+(j + q.back()*w[i])*(j + q.back()*w[i])*u)
					q.pop_back();
				if (!q.empty() &amp;&amp; k - q.front() &gt; m[i])
					q.pop_front();
				q.push_back(k);
				dp[i][k * w[i] + j] = dp[i - 1][j + q.front() * w[i]] + (k - q.front()) * v[i]+(j + q.front() * w[i])*(j + q.front() * w[i])*u;
			}
		}
	}
	long long u=e-c[n];
	cout&lt;&lt;dp[n][W]+u*W*W;
	return 0;
}

</code></pre>
<h2 id="4-斜率优化318更新">4、斜率优化（3.18更新）</h2>
<p>斜率优化是指对于转移方程为形如 y=kx+b 的一次函数时，使用的一种优化方式，其维护一个队列，队列中存储一次函数，设目前对应 x=i，要加入 y=k_5 x+b_5。<br>
则：</p>
<ul>
<li>若队列大小不大于 1，不进行删除操作，否则进行删除。</li>
<li>设队列前两个元素对应 y_1 = k_1 x+b_1 和 y_2 = k_2 x +b_2，x_0 使 k_1 x_0+b_1=k_2 x_0+b_2，则当 x_0 \req i 时停止删除，否则删除队首并继续删除。</li>
<li>队尾删除则对应当队尾和新插入函数的交点的横坐标小于等于队尾和倒数第二个的时删除。</li>
<li>最后用队首修改元素。</li>
</ul>
<p>示例：<a href="https://www.luogu.com.cn/problem/P5017">P5017 [NOIP2018 普及组] 摆渡车</a><br>
解法：我们用 dp_i 来表示第 i 时刻发车的最小等待时间，s_i 表示前 i 时刻学生到达时间之和，cnt_i 表示前 i 时刻到达的学生人数，则 dp_i=\min{dp_j+s_j-cnt_j \times i+cnt_i\times i+s_i}，得：</p>
<ul>
<li>k=-cnt_j</li>
<li>b=dp_j+s_j</li>
<li>转移时额外加 cnt_i\times i+s_i</li>
<li>x=i</li>
</ul>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
int n,m,t,s[4000009],dp[4000009],cnt[4000009],maxt;
inline int k(int i){
	return -cnt[i];
}
inline int b(int i){
	return dp[i]+s[i];
}
inline int x(int i){
	return i;
}
inline int dp_add(int i){
	return cnt[i]*i-s[i];
}
inline bool cmpadd(int l1,int l2,int l3){
	return (b(l1)-b(l2))*(k(l3)-k(l2))&gt;=(b(l2)-b(l3))*(k(l2)-k(l1));
}
inline bool cmpkill(int l1,int l2,int kill_time){
	return b(l2)-b(l1)&lt;=kill_time*(k(l1)-k(l2));
}
signed main(){
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%lld&quot;,&amp;t);
		maxt=max(maxt,t);
		cnt[t]+=1;
		s[t]+=t;
	}
	for(int i=1;i&lt;=maxt+m;i++){
		cnt[i]+=cnt[i-1];
		s[i]+=s[i-1];
	}
	deque&lt;int&gt;q;
	for(int i=0;i&lt;m;i++){
		dp[i]=cnt[i]*i-s[i];
	}
	for(int i=m;i&lt;=maxt+m;i++){
		if(!(q.size()&gt;0&amp;&amp;k(q.back())==k(i-m)&amp;&amp;b(q.back())&lt;=b(i-m))){
			if((q.size()&gt;0&amp;&amp;k(q.back())==k(i-m)))q.pop_back();
			while(q.size()&gt;=2){
				int a=q.back();
				q.pop_back();
				int b=q.back();
				if(!cmpadd(b,a,i-m)){
					q.push_back(a);
					break;
				}
			}
			q.push_back(i-m);
		}
		while(q.size()&gt;=2){
			int a=q.front();
			q.pop_front();
			int b=q.front();
			if(!cmpkill(a,b,i)){
				q.push_front(a);
				break;
			}
		}
		int a=q.front();
		dp[i]=k(a)*x(i)+b(a)+dp_add(i);
	}
	int ans=9e18;
	for(int i=maxt;i&lt;=maxt+m;i++){
		ans=min(ans,dp[i]);
	}
	printf(&quot;%lld&quot;,ans);
	return 0;
}

</code></pre>
<p>练习：敬请期待。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分治]]></title>
        <id>https://NuclearPasta3579.github.io/post/fen-zhi/</id>
        <link href="https://NuclearPasta3579.github.io/post/fen-zhi/">
        </link>
        <updated>2023-08-08T08:13:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1分治">1.分治</h1>
<p>分治是针对子问题最优影响主问题最优，且先分析子问题可以简化主问题时使用的，通常分为非分治情况、<br>
分治前操作、分治问题、分治后处理，这里是一个例子：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
struct point{
    long long x,y;
}p[400001],t[400001];
int n;
inline long long dist(point xx,point xy){
    return (xx.x-xy.x)*(xx.x-xy.x)+(xx.y-xy.y)*(xx.y-xy.y);
}
bool cmp(point xx,point xy){
    return xx.x&lt;xy.x;
}
bool cmp1(point xx,point xy){
    return xx.y&lt;xy.y;
}
inline long long solve(int l,int r){//分治
    //非分治情况
    if(l==r){return 9e18;}
    //分治前处理
    int mid=(l+r)/2;
    long long tlx=p[mid].x;
    //分治问题
    long long d=min(solve(l,mid),solve(mid+1,r));
    //分治后处理
    int u=l,v=mid+1,tp=0;
    while(u&lt;=mid||v&lt;=r){
        if(u&gt;mid||(v&lt;=r&amp;&amp;p[v].y&lt;p[u].y)){
            tp++;
            t[tp]=p[v];
            v++;
        }
        else{
            tp++;
            t[tp]=p[u];
            u++;
        }
    }
    for(int i=1;i&lt;=tp;i++)
    {
        p[l+i-1]=t[i];
    }
    int cnt=0;
    for(int i=l;i&lt;=r;i++)
    {
        if(fabs(p[i].x-tlx)&lt;sqrt(d)){t[++cnt]=p[i];}
    }
    for(int i=1;i&lt;cnt;i++){
        for(int j=i+1;j&lt;=cnt&amp;&amp;1.0*(t[j].y-t[i].y)&lt;sqrt(d);j++){
            d=min(d,dist(t[i],t[j]));
        }
    }
    return d;
}
int main(){
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%lld%lld&quot;,&amp;p[i].y,&amp;p[i].x);
    }
    sort(p+1,p+n+1,cmp);
    printf(&quot;%lld&quot;,solve(1,n));
    return 0;
}
</code></pre>
<h1 id="2分治基本应用">2.分治基本应用</h1>
<h2 id="1排序">1.排序</h2>
<p>快速排序和归并排序是较为常见的运用分治的排序算法。<br>
快速排序时间复杂度介于 \operatorname{O}(\log n) 和 \operatorname{O}(n^2) 之间，是指对于一个序列，进行如下操作：</p>
<ol>
<li>非分治情况：当只需要对一个元素排序时什么都不用干。</li>
<li>分治前操作：找一个基准元素，将比其小的放在其左边，比其大的放在其右边。</li>
<li>分治问题：对基准元素前面和后面的元素进行排序。</li>
<li>分治后无需进行任何操作。<br>
代码：</li>
</ol>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
int n,a[100009];
void f_sort(int begin,int end){
  	 //非分治情况
    if(begin&gt;=end)return;
	 //分治前处理
    int u=(begin+end)/2;
    int ut=a[u];
    a[u]=a[end];
    a[end]=ut;
    int l=begin,r=end-1;
    while(l&lt;=r){
        while(a[l]&lt;a[end])l++;
        while(a[r]&gt;a[end])r--;
        if(l&lt;=r){
            int t=a[l];
            a[l]=a[r];
            a[r]=t;
            l++,r--;
        }
    }
    //分治问题
    if(begin&lt;r)f_sort(begin,r);
    if(l&lt;end)f_sort(l,end);
}
int main(){
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);
    f_sort(1,n);
    for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,a[i]);
    return 0;
}
</code></pre>
<p>归并排序时间复杂度比较稳，为 \operatorname{O}(n\log n)，但需要双倍空间（多开一个数组）。<br>
其操作是：</p>
<ol>
<li>非分治情况：一个元素无需排序；</li>
<li>分治前处理：无需任何处理；</li>
<li>分治问题：先对前一半和后一半进行排序；</li>
<li>分治后处理：将两半合并：</li>
</ol>
<ul>
<li>法一：给定两个指针，一个指向前一半最前面，一个指向后一半最后面，比较哪一个应该优先哪一个放到另一个数组的最后面，同时指针向后移。</li>
<li>法二：实现涉及双指针（<a href="https://nuclearpasta3579.github.io/post/shuang-zhi-zhen/">由此</a>学习双指针）遍历前半段时将后半段中比对应元素小且未进另一个数组的加进去，之后把那个元素加进去。<br>
不管用那种方法，都要把前若干个元素按另一个数组重新处理。</li>
</ul>
<p>代码：<br>
法一：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#define int long long
using namespace std;
int n,s[500001];
int b[500001];
void merge_sort(int begin,int end){
	//非分治情况
	if(begin&gt;=end)return;
   //分治问题
	int m=(begin+end)/2;
	merge_sort(begin,m);
	merge_sort(m+1,end);
   //分治后处理
	int atl=begin,atr=m+1,cnt=0;
	while(atl&lt;=m||atr&lt;=end){
		if(atl&gt;m||(atr&lt;=end&amp;&amp;s[atl]&gt;s[atr])){
			b[++cnt]=s[atr];
			atr++;
		}
		else{
			b[++cnt]=s[atl];
			atl++;
		}
	}
	for(int i=1;i&lt;=cnt;i++){
		s[begin+i-1]=b[i];
	}
	return;
}
signed main(){
    scanf(&quot;%lld&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++){scanf(&quot;%lld&quot;,&amp;s[i]);}
    merge_sort(1,n);
    for(int i=1;i&lt;=n;i++){printf(&quot;%lld &quot;,s[i]);}
    return 0;
}
</code></pre>
<p>法二：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#define int long long
using namespace std;
int n,s[500001];
int b[500001];
void merge_sort(int begin,int end){
	//非分治情况
	if(begin&gt;=end)return;
   //分治问题
	int m=(begin+end)/2;
	merge_sort(begin,m);
	merge_sort(m+1,end);
   //分治后处理
	int atr=m,cnt=0;
	for(int i=begin;i&lt;=m;i++){
     while(atr&lt;end&amp;&amp;s[atr+1]&lt;s[i])b[++cnt]=s[++atr];
     b[++cnt]=s[i];
   }
	for(int i=1;i&lt;=cnt;i++){
		s[begin+i-1]=b[i];
	}
	return;
}
signed main(){
    scanf(&quot;%lld&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++){scanf(&quot;%lld&quot;,&amp;s[i]);}
    merge_sort(1,n);
    for(int i=1;i&lt;=n;i++){printf(&quot;%lld &quot;,s[i]);}
    return 0;
}
</code></pre>
<p>归并排序不仅用于排序，还用于求逆序对。<br>
逆序对是指序列中一对元素对 a_i,a_j，使得：</p>
<ul>
<li>i&lt;j</li>
<li>a_i &gt;a_j（依情况改为 a_i \geq a_j）</li>
</ul>
<p>而用归并排序记录的方式是在排序的同时记录一下后半段每个元素比前半段的元素优先的个数。<br>
代码：<br>
法一：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#define int long long
using namespace std;
int n,s[500001];
int b[500001];
long long ans;
void merge_sort(int begin,int end){
	//非分治情况
	if(begin&gt;=end)return;
   //分治问题
	int m=(begin+end)/2;
	merge_sort(begin,m);
	merge_sort(m+1,end);
   //分治后处理
	int atl=begin,atr=m+1,cnt=0;
	while(atl&lt;=m||atr&lt;=end){
		if(atl&gt;m||(atr&lt;=end&amp;&amp;s[atl]&gt;s[atr])){
			b[++cnt]=s[atr];
			atr++;
  			if(atl&lt;=m)ans+=m-atl+1;
		}
		else{
			b[++cnt]=s[atl];
			atl++;
		}
	}
	for(int i=1;i&lt;=cnt;i++){
		s[begin+i-1]=b[i];
	}
	return;
}
signed main(){
    scanf(&quot;%lld&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++){scanf(&quot;%lld&quot;,&amp;s[i]);}
    merge_sort(1,n);
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
<p>法二：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#define int long long
using namespace std;
int n,s[500001];
int b[500001];
long long ans=0;
void merge_sort(int begin,int end){
	//非分治情况
	if(begin&gt;=end)return;
   //分治问题
	int m=(begin+end)/2;
	merge_sort(begin,m);
	merge_sort(m+1,end);
   //分治后处理
	int atr=m,cnt=0;
	for(int i=begin;i&lt;=m;i++){
     while(atr&lt;end&amp;&amp;s[atr+1]&lt;s[i]){b[++cnt]=s[++atr];ans++;}
     b[++cnt]=s[i];
   }
	for(int i=1;i&lt;=cnt;i++){
		s[begin+i-1]=b[i];
	}
	return;
}
signed main(){
    scanf(&quot;%lld&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++){scanf(&quot;%lld&quot;,&amp;s[i]);}
    merge_sort(1,n);
    printf(&quot;%lld&quot;,ans);
    return 0;
}
</code></pre>
<h2 id="2cdq分治">2.CDQ分治</h2>
<p>cdq分治，是一类算法的总称，它针对的是点对计数，其操作如下：</p>
<ol>
<li>非分治情况：一个点；</li>
<li>分治前/后操作：求出前半段与后半段各一个点配对的情况。</li>
<li>分治问题：求前半段内及后半段内的点对。</li>
</ol>
<h2 id="3点分治">3.点分治</h2>
<p>敬请期待。</p>
<h1 id="例题">例题</h1>
<p><a href="https://www.luogu.com.cn/training/265997">普通分治</a><br>
<a href="https://www.luogu.com.cn/training/265999">快速排序和归并排序</a><br>
<a href="https://www.luogu.com.cn/training/266000">cdq分治</a></p>
<h1 id="精讲">精讲</h1>
<p>题目：<a href="https://www.luogu.com.cn/problem/P7883">平面最近点对</a><br>
解法：<br>
分治前先将所有点按 x 排序。<br>
分治是：</p>
<ol>
<li>非分治情况：一个点形成不了答案（一个巴掌拍不响）。</li>
<li>分治前操作：记录一下中间点的 x 坐标。</li>
<li>分治问题：处理一下前半段和后半段的点对情况。</li>
<li>分治后处理：</li>
</ol>
<ul>
<li>处理答案：首先，我们只取 x 坐标与分治前 x 坐标相差不超过最短距离的点，然后枚举所有在这些点中 y 坐标距离不超过最近点对距离的两点更新答案。</li>
<li>处理答案前按 y 轴顺序归并两点。</li>
</ul>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
struct point{
    long long x,y;
}p[400001],t[400001];
int n;
inline long long dist(point xx,point xy){
    return (xx.x-xy.x)*(xx.x-xy.x)+(xx.y-xy.y)*(xx.y-xy.y);
}
bool cmp(point xx,point xy){
    return xx.x&lt;xy.x;
}
bool cmp1(point xx,point xy){
    return xx.y&lt;xy.y;
}
inline long long solve(int l,int r){
    //非分治情况
    if(l==r){return 9e18;}
    //分治前操作
    int mid=(l+r)/2;
    long long tlx=p[mid].x;
    //分治问题
    long long d=min(solve(l,mid),solve(mid+1,r));
    //分治后处理
    int u=l,v=mid+1,tp=0;
    while(u&lt;=mid||v&lt;=r){
        if(u&gt;mid||(v&lt;=r&amp;&amp;p[v].y&lt;p[u].y)){
            tp++;
            t[tp]=p[v];
            v++;
        }
        else{
            tp++;
            t[tp]=p[u];
            u++;
        }
    }
    for(int i=1;i&lt;=tp;i++)
    {
        p[l+i-1]=t[i];
    }
    int cnt=0;
    for(int i=l;i&lt;=r;i++)
    {
        if(fabs(p[i].x-tlx)&lt;sqrt(d)){t[++cnt]=p[i];}
    }
    for(int i=1;i&lt;cnt;i++){
        for(int j=i+1;j&lt;=cnt&amp;&amp;1.0*(t[j].y-t[i].y)&lt;sqrt(d);j++){
            d=min(d,dist(t[i],t[j]));
        }
    }
    return d;
}
int main(){
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%lld%lld&quot;,&amp;p[i].y,&amp;p[i].x);
    }
    sort(p+1,p+n+1,cmp);
    printf(&quot;%lld&quot;,solve(1,n));
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最短路]]></title>
        <id>https://NuclearPasta3579.github.io/post/zui-duan-lu/</id>
        <link href="https://NuclearPasta3579.github.io/post/zui-duan-lu/">
        </link>
        <updated>2023-08-08T08:12:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1最短路问题">1.最短路问题</h1>
<p>给定一个图，图中边带有边权，求从一个点到另一个点的路径的最小距离从一个点出发的是单源最短路问题，多个点出发的对应多源最短路问题。</p>
<h1 id="2最短路问题专有名词">2.最短路问题专有名词</h1>
<ol>
<li>负权边：一条边，经过时距离减小。</li>
<li>负权环：一个环，绕一圈后距离减小。</li>
</ol>
<h1 id="3最短路算法">3.最短路算法</h1>
<h2 id="1广搜双端队列广搜">1.广搜&amp;&amp;双端队列广搜</h2>
<p>广搜是最基础且其中最快的方法，每扩展到一个点就把它加入队列进行扩展，然后不再更改，时间复杂度 O(|V|+|E|)，但只能处理所有边权为 1 的最短路，当出现边权为 0 的边时，为了保证有序性，需将对应点放在队首，于是有了双端队列广搜。<br>
广搜代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
const int maxn=1000005;
int s[1000005],n,m;
bool vis[maxn];
struct edge{
	int end,len;
}; 
vector&lt;edge&gt;map[maxn];
queue&lt;int&gt;q;
inline void distance_srh(){
	q.push(1);
	memset(s,0x3f3f3f3f,sizeof(s));
	s[1]=0;
	while(!q.empty()){
		int d=q.front();
		q.pop();
		if(vis[d])continue;
		vis[d]=true;
		for(int i=0;map[d].size()&gt;i;i++){
			if(s[map[d][i].end]==0x3f3f3f3f||s[map[d][i].end]&gt;s[d]+map[d][i].len){
				s[map[d][i].end]=s[d]+map[d][i].len;
				q.push(map[d][i].end);
				continue;
			}
		}
	}
}
int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;m&gt;=i;i++){
    	int u,v;
        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
        edge t;
        t.end=v;
		t.len=1;
        map[u].push_back(t);
        t.end=u;
        map[v].push_back(t);
    }
    distance_srh();
    for(int i=1;n&gt;=i;i++){
        printf(&quot;%d\n&quot;,s[i]);
    }
    return 0;
}

</code></pre>
<p>精讲：做<a href="https://www.luogu.com.cn/problem/P1144">最短路计数</a>时，如果更新最短路，则使最短路条数为用来更新此点最短路的最短路条数，遍历到最短路与扩展长度相同时，对应点最短路条数加上此点最短路条数。<br>
代码：</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
const int maxn=1000005;
int s[1000005],n,m,ans[1000005];
bool vis[maxn];
struct edge{
	int end,len;
}; 
vector&lt;edge&gt;map[maxn];
queue&lt;int&gt;q;
inline void distance_srh(){
	q.push(1);
	memset(s,0x3f3f3f3f,sizeof(s));
	s[1]=0;
	ans[1]=1;
	while(!q.empty()){
		int d=q.front();
		q.pop();
		if(vis[d])continue;
		vis[d]=true;
		for(int i=0;map[d].size()&gt;i;i++){
			if(s[map[d][i].end]==0x3f3f3f3f||s[map[d][i].end]&gt;s[d]+map[d][i].len){
				s[map[d][i].end]=s[d]+map[d][i].len;
				q.push(map[d][i].end);
				ans[map[d][i].end]=ans[d];
				continue;
			}
			if(s[d]+map[d][i].len==s[map[d][i].end]){
				ans[map[d][i].end]=(ans[d]+ans[map[d][i].end])%100003;
			}
		}
	}
}
int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;m&gt;=i;i++){
    	int u,v;
        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
        edge t;
        t.end=v;
		t.len=1;
        map[u].push_back(t);
        t.end=u;
        map[v].push_back(t);
    }
    distance_srh();
    for(int i=1;n&gt;=i;i++){
        printf(&quot;%d\n&quot;,ans[i]);
    }
    return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/training/211360">练习</a><br>
其中有题卡常，不知道如何防卡常的请移步<a href="https://www.luogu.com.cn/blog/lcm15987/FKCBK">这里</a></p>
<h2 id="2bellman-fold">2.Bellman-Fold</h2>
<p><code>Bellman-Fold</code>是一个单源最短路算法，其可以解决基本上所有的最短路问题，且能判断负环，时间复杂度为 O(|V||E|)。<br>
<code>Bellman-Fold</code>会枚举 n-1 次，遍历每条边进行更新答案，然后再一次遍历每条边，此时若还能更新最短路，则对应出现负环。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt; 
#include&lt;cstring&gt; 
using namespace std;
long long n,dist[100001],m,cnt=0,t,wk;
bool isused[100001];
struct edge{
	long long st,ed,len;
};
edge e[100001];
void edgep(long long u,long long v,long long w){
	++cnt;
    e[cnt].st=u;
    e[cnt].ed=v;
    e[cnt].len=w;
}
void bsrh(long long begin){
	
	memset(isused,true,sizeof(isused));
	isused[begin]=true;
	for(long long i=1;i&lt;n;i++){
		for(long long j=1;j&lt;=cnt;j++){
			if(isused[e[j].st]){
				isused[e[j].ed]=true;
				dist[e[j].ed]=min(dist[e[j].st]+e[j].len,dist[e[j].ed]);
			}
		}
	}
	
	for(long long j=1;j&lt;=cnt;j++){
		if(!isused[e[j].st])
			continue;
		if(dist[e[j].st]+e[j].len&lt;dist[e[j].ed]){
			printf(&quot;Cannot be solved!\n&quot;);
			return;			 
		}
	}
	for(int i=1;i&lt;=n;i++){
   	  printf(&quot;%lld &quot;,dist[i]);
   }
}
int main(){
    memset(dist,0x3f3f3f3f,sizeof(dist));
    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
    cnt=0;
    for(long long j=1;j&lt;=m;j++){
        long long u,v,w;
        scanf(&quot;%lld%lld%lld&quot;,&amp;u,&amp;v,&amp;w);
        edgep(u,v,w);
    }
    dist[1]=0;
    bsrh(1);
    return 0;
}
</code></pre>
<p><code>Bellman-Fold</code>有许多优化，其中较为常见的是队列优化以及队列优化的其他优化，队列优化是指暴力地从原点开始，只要更新最短路，就从此点先后拓展，一个点访问 n 次即有负环。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
long long n,m,s;
long long u,v,w;
bool vis[10001];
struct edge{
	long long end,len;
};
vector&lt;edge&gt;e[10001];
long long dist[10001];
void Bellman_Fold(long long begin){
	for(long long i=1;i&lt;=n;i++){
		dist[i]=3e10;
	}
	dist[begin]=0;
	vis[begin]=true;
	queue&lt;long long&gt;q;
	q.push(begin);
	while(!q.empty()){
		long long d=q.front();
		q.pop();
		for(int i=0;i&lt;e[d].size();i++){
			if(!vis[e[d][i].end]||dist[d]+e[d][i].len&lt;dist[e[d][i].end]){
				vis[e[d][i].end]=true;
				dist[e[d][i].end]=dist[d]+e[d][i].len;
				q.push(e[d][i].end);
			}
		}
	}
	for(long long i=1;i&lt;=n;i++){
	    if(!vis[i])
	       printf(&quot;%lld &quot;,(1&lt;&lt;31)-1);
	    else
		    printf(&quot;%lld &quot;,dist[i]);
	}
}
int main(){
	scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;s);
	for(long long i=1;i&lt;=m;i++){
		scanf(&quot;%lld%lld%lld&quot;,&amp;u,&amp;v,&amp;w);
		e[u].push_back(edge{v,w});
	}
	Bellman_Fold(s);
	return 0;
}
</code></pre>
<p>因为队列优化节省了大量更新，所以其最快可以达到 O(|V|+|E|)，故而大型比赛通常都会在部分最短路题目中卡掉该解法。<br>
<strong>精讲题目：</strong><a href="https://www.luogu.com.cn/problem/P2865">here</a><br>
解法：每个点存最短路和次短路，跑的时候，不管更新的是最短路还是次短路都要更新。本博主开了<code>SLF</code>优化，对应如果加入队列的值比队首更优，则加入队首。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
long long n,m,s,t,u,v,w,dist[2][5001];
bool vis[5001];
struct edge{
	long long ed,len;
	
};
vector&lt;edge&gt;e[5001];
deque&lt;long long&gt;q;
inline void SLF(long long k){
    if(q.empty()||dist[0][k]&lt;dist[0][q.front()]||(dist[0][k]==dist[0][q.front()]&amp;&amp;dist[1][k]&lt;dist[1][q.front()]))q.push_front(k);
    else q.push_back(k);
}
void Bellman_Fold(long long begin){
	memset(dist,0x3f3f3f3f,sizeof(dist));
	memset(vis,false,sizeof(vis));
	q.push_back(begin);
	dist[0][begin]=0;
	while(!q.empty()){
		long long d=q.front();
		q.pop_front();
		if(vis[d])continue;
		vis[d]=false;
		for(long long i=0;e[d].size()&gt;i;i++){
		    if(dist[0][e[d][i].ed]&gt;dist[0][d]+e[d][i].len){
		        dist[1][e[d][i].ed]=dist[0][e[d][i].ed];
                if(dist[1][d]+e[d][i].len&lt;dist[1][e[d][i].ed])dist[1][e[d][i].ed]=dist[1][d]+e[d][i].len;
				dist[0][e[d][i].ed]=dist[0][d]+e[d][i].len;
				if(!vis[e[d][i].ed])SLF(e[d][i].ed);
			}
			else if(dist[1][e[d][i].ed]&gt;dist[0][d]+e[d][i].len&amp;&amp;dist[0][e[d][i].ed]!=dist[0][d]+e[d][i].len){
				dist[1][e[d][i].ed]=dist[0][d]+e[d][i].len;
				if(!vis[e[d][i].ed])SLF(e[d][i].ed);
			}
            else if(dist[1][e[d][i].ed]&gt;dist[1][d]+e[d][i].len&amp;&amp;dist[1][e[d][i].ed]!=dist[1][d]+e[d][i].len){
				dist[1][e[d][i].ed]=dist[1][d]+e[d][i].len;
				if(!vis[e[d][i].ed])SLF(e[d][i].ed);
			}
		}
	}
}
int main(){
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
	for(long long i=1;m&gt;=i;i++){
		scanf(&quot;%lld%lld%lld&quot;,&amp;u,&amp;v,&amp;w);
		e[u].push_back(edge{v,w});
		e[v].push_back(edge{u,w});
	}
	Bellman_Fold(n);
	printf(&quot;%lld\n&quot;,dist[1][1]);
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/training/156445">练习</a></p>
<h2 id="3dijkstra">3.Dijkstra</h2>
<p><code>Dijkstra</code>是一种常用的单源最短路算法，其无法处理带负权边的问题，但更快。<br>
跑<code>Dijkstra</code>时，我们每次会选未扩展且最短路最小的点进行扩展，并更新其他点的最短路。<br>
一个裸的<code>Dijkstra</code>的复杂度为 O(|V|^2+|E|)，但选扩展点的任务可以用优先队列来维护，使其复杂度变为 O((|V|+|E|)\log |V|)。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
unsigned long long n,m,s,t,u,v,w,dist[100001];
bool vis[100001];
struct edge{
	unsigned long long ed,len;
	
};
bool operator&lt;(edge mk,edge k){
		return mk.len&gt;k.len;
	}
vector&lt;edge&gt;e[100001];
priority_queue&lt;edge&gt;q;
void Dijkstra(unsigned long long begin){
	memset(dist,0x3f3f3f3f,sizeof(dist));
	memset(vis,false,sizeof(vis));
	q.push(edge{begin,0});
	dist[begin]=0;
	while(!q.empty()){
		edge d=q.top();
		q.pop();
		if(vis[d.ed])continue;
		vis[d.ed]=true;
		for(unsigned long long i=0;e[d.ed].size()&gt;i;i++){
			if(dist[e[d.ed][i].ed]&gt;dist[d.ed]+e[d.ed][i].len){
				dist[e[d.ed][i].ed]=dist[d.ed]+e[d.ed][i].len;
				q.push(edge{e[d.ed][i].ed,dist[e[d.ed][i].ed]});
			}
		}
	}
}
int main(){
	scanf(&quot;%llu%llu%llu&quot;,&amp;n,&amp;m,&amp;s);
	for(unsigned long long i=1;m&gt;=i;i++){
		scanf(&quot;%lld%lld%lld&quot;,&amp;u,&amp;v,&amp;w);
		e[u].push_back(edge{v,w});
	}
	Dijkstra(s);
	for(unsigned long long i=1;i&lt;=n;i++){
	    printf(&quot;%llu &quot;,dist[i]);
	}
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P1462">精讲：通往奥格瑞玛的道路</a><br>
此题需要二分对应的最大的一次收取的费用，跑最短路的时候，不走费用超过二分值的点，图中边的权值为走过后的损失的血量，如果其超过歪嘴哦的血量，则正确答案大于这个值。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
long long n,m,s,t,u,v,w,b,maxf,a[10001],dist[10001];
bool vis[10001];
struct edge{
	long long ed,len;
	
};
bool operator&lt;(edge mk,edge k){
		return mk.len&gt;k.len;
	}
vector&lt;edge&gt;e[500001];
priority_queue&lt;edge&gt;q;
inline void Dijkstra(long long begin,long long jk){
	memset(dist,0x3f3f3f3f,sizeof(dist));
	memset(vis,false,sizeof(vis));
	q.push(edge{begin,0});
	dist[begin]=0;
	while(!q.empty()){
		edge d=q.top();
		q.pop();
		if(vis[d.ed])continue;
		vis[d.ed]=true;
		for(long long i=0;e[d.ed].size()&gt;i;i++){
			if(a[e[d.ed][i].ed]&gt;jk)continue;
			if(dist[e[d.ed][i].ed]&gt;dist[d.ed]+e[d.ed][i].len){
				dist[e[d.ed][i].ed]=dist[d.ed]+e[d.ed][i].len;
				q.push(edge{e[d.ed][i].ed,dist[e[d.ed][i].ed]});
			}
		}
	}
}
int main(){
	scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;b);
	long long l,r=~0x3f3f3f3f,mid;
	for(long long i=1;i&lt;=n;i++){
		scanf(&quot;%lld&quot;,&amp;a[i]);
		r=max(r,a[i]);
	}
	for(long long i=1;i&lt;=m;i++){
		scanf(&quot;%lld%lld%lld&quot;,&amp;u,&amp;v,&amp;w);
		if(w&gt;b||(w==b&amp;&amp;!((u==1&amp;&amp;v==n)||(u==n&amp;&amp;v==1))))continue;
		e[u].push_back(edge{v,w});
		e[v].push_back(edge{u,w});
	}
	l=max(a[1]-1,max(a[n]-1,0ll));
	bool ktv=false;
	do{
		mid=(l+r+1)/2;
		Dijkstra(1,mid);
		if(dist[n]&lt;=b){r=mid;ktv=true;}
		else l=mid;
	}
	while(r-l&gt;1);
	if(ktv&amp;&amp;r&gt;=l)printf(&quot;%lld\n&quot;,r);
	else {
		Dijkstra(1,r);
		if(dist[n]&lt;=b){printf(&quot;%lld\n&quot;,r);}
		else printf(&quot;AFK\n&quot;);
	}
	
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/training/185225">练习</a></p>
<h2 id="4floyd">4.Floyd</h2>
<p><code>Floyd</code>是个 O(|V|^3) 的全源最短路算法，使用前需保证此图不存在负环。其用 dist_{i,j} 存储从 i 到 j 的最短路，我们设从 i 到 j 的一条路中经过 k，则 dist_{i,j}=\min(dist_{i,j},dist_{i,k}+dist_{k,j})，遍历时先枚举 k，再枚举 i 和 j。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,q,dist[101][101],u,v,w;
int main(){
    memset(dist,0x3f3f3f3f,sizeof(dist));
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)dist[i][i]=0;
    for(int i=1;i&lt;=m;i++){
        scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);
        dist[u][v]=w;
    }
    for(int k=1;k&lt;=n;k++){
        for(int i=1;i&lt;=n;i++){
            for(int j=1;j&lt;=n;j++){
                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
            }
        }
    }
    scanf(&quot;%d&quot;,&amp;q);
    for(int i=1;i&lt;=q;i++){
        scanf(&quot;%d %d&quot;,&amp;u,&amp;v);
        printf(&quot;%d\n&quot;,dist[u][v]==0x3f3f3f3f?-1:dist[u][v]);
    }
    return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P6512">精讲：[QkOI#R1] Quark and Flying Pigs</a><br>
此题要用<code>Floyd</code>进行预处理，然后将所有的猪按出现时间排序，用 dp_i 表示第 i 只猪被抓到时最多抓了几只猪，得 dp_i=\max{\max\limits_{ t_i+dist_{i,j}\leq t_j}{dp_j+1},1}。<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
long long n,m,k;
long long u,v,w,dist[209][209],dp[5009],ans=0;
bool geted[209][209];
struct pig{
	long long t,vs;
};
pig p[5009];
bool cmp(pig x,pig y){
	return x.t&lt;y.t;
}
int main(){
	scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k);
	for(long long i=1;i&lt;=m;i++){
		scanf(&quot;%lld%lld%lld&quot;,&amp;u,&amp;v,&amp;w);
		dist[u][v]=w,dist[v][u]=w;
		geted[u][v]=true,geted[v][u]=true;
	}
	for(long long i=1;i&lt;=n;i++){
		geted[i][i]=true;
		dist[i][i]=0;
	}
	for(long long k=1;k&lt;=n;k++)
		for(long long i=1;i&lt;=n;i++)
			for(long long j=1;j&lt;=n;j++)
				if(geted[i][k]&amp;&amp;geted[k][j]){
					if(!geted[i][j])dist[i][j]=dist[i][k]+dist[k][j];
					else dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
					geted[i][j]=true;
				}
	p[0].t=0,p[0].vs=1;
	for(long long i=1;i&lt;=k;i++){
		scanf(&quot;%lld%lld&quot;,&amp;p[i].t,&amp;p[i].vs);
	}
	sort(p+1,p+k+1,cmp);
	memset(dp,~0x3f3f3f3f,sizeof(dp));
	dp[0]=0;
	for(long long i=1;i&lt;=k;i++){
		for(long long j=0;j&lt;i;j++){
			if(geted[p[j].vs][p[i].vs]&amp;&amp;p[i].t-p[j].t&gt;=dist[p[j].vs][p[i].vs])
			dp[i]=max(dp[i],dp[j]+1);
		}
	}
	for(long long i=1;i&lt;=k;i++){
		ans=max(ans,dp[i]);
	}
	printf(&quot;%lld&quot;,ans);
	return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/training/269039#information">练习</a></p>
<h2 id="5a">5.A*</h2>
<p><code>A*</code>是一个单源最短路算法，且只能处理一个终点，故更常用在变形上。它与<code>Dijkstra</code>类似，但会预测后续的答案，并用目前答案加上预处理值进行比较。<br>
<code>A*</code>有个好处在于若先从终点出发跑最短路求预处理值，第 k 个到达终点的是第 k 短路，故而<code>A*</code>有时被用在解 k 短路上。<br>
<code>A*</code>解 k 短路代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
unsigned long long n,m,s,t,u,v,w,dist[1009],k;
bool vis[1009];
struct edge{
	unsigned long long ed,len;
	
};
bool operator&lt;(edge mk,edge k){
		return mk.len&gt;k.len;
	}
struct toa_s{
    unsigned long long ed,len;
};
bool operator&lt;(toa_s mk,toa_s k){
    return mk.len+dist[mk.ed]&gt;k.len+dist[k.ed];
}
vector&lt;edge&gt;e[1009],el[1009];
priority_queue&lt;edge&gt;q;
priority_queue&lt;toa_s&gt;pq;
void Dijkstra(unsigned long long begin){
	memset(dist,0x3f3f3f3f,sizeof(dist));
	memset(vis,false,sizeof(vis));
	q.push(edge{begin,0});
	dist[begin]=0;
	while(!q.empty()){
		edge d=q.top();
		q.pop();
		if(vis[d.ed])continue;
		vis[d.ed]=true;
		for(unsigned long long i=0;e[d.ed].size()&gt;i;i++){
			if(dist[e[d.ed][i].ed]&gt;dist[d.ed]+e[d.ed][i].len){
				dist[e[d.ed][i].ed]=dist[d.ed]+e[d.ed][i].len;
				q.push(edge{e[d.ed][i].ed,dist[e[d.ed][i].ed]});
			}
		}
	}
}
int ola[1009];
void a_star(unsigned long long begin){
	pq.push(toa_s{begin,0});
	while(!pq.empty()&amp;&amp;ola[t]&lt;k){
		toa_s d=pq.top();
		pq.pop();
		if(ola[d.ed]&gt;=k)continue;
		ola[d.ed]++;
		if(d.ed==t){
			printf(&quot;%llu\n&quot;,d.len);
			if(ola[d.ed]&gt;=k)return;
		}
		for(unsigned long long i=0;el[d.ed].size()&gt;i;i++){
			if(ola[el[d.ed][i].ed]&lt;k){
				pq.push(toa_s{el[d.ed][i].ed,d.len+el[d.ed][i].len});
			}
		}
	}
	for(int i=ola[t]+1;i&lt;=k;i++){
	    printf(&quot;-1\n&quot;);
	}
}
int main(){
	scanf(&quot;%llu%llu%llu&quot;,&amp;n,&amp;m,&amp;k);
	for(unsigned long long i=1;m&gt;=i;i++){
		scanf(&quot;%llu%llu%llu&quot;,&amp;u,&amp;v,&amp;w);
		el[u].push_back(edge{v,w});
		e[v].push_back(edge{u,w});
	}
	s=n,t=1;
	Dijkstra(t);
	a_star(s);
	return 0;
}

</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P2901">练习</a></p>
<h1 id="4最短路的特殊应用">4.最短路的特殊应用</h1>
<h2 id="1差分约束">1.差分约束</h2>
<h2 id="问题">问题</h2>
<p>给定变量 x_1,x_2,...x_n，给出 m 个不等式，通过不等式求变量的解的最值。</p>
<h2 id="解法">解法</h2>
<p>n 个变量对应 n 个点，根据不等式对应的大于等于关系建边，然后跑最短路可以得最大值，根据不等式对应的小于等于关系建边，注意边的改变方式取反，然后跑最短路，可以得最小值。<br>
<a href="https://www.luogu.com.cn/training/269058">练习</a></p>
<h2 id="2分层图">2.分层图</h2>
<p>给定一个图，有一些变量影响边权，求最短路。</p>
<h2 id="方法">方法</h2>
<p>将图按变量分层，然后跑最短路。<br>
<a href="https://www.luogu.com.cn/training/269060">练习</a></p>
<h2 id="3同余最短路">3.同余最短路</h2>
<p>给定一个模数和改变数的变量值及其成本，求出从一个数到余数为一个数的最小成本。</p>
<h2 id="解法-2">解法</h2>
<p>每种余数的情况对应一个点，通过余数的可加性，假设一个余 i 的数通过成本为 c 的方式变为余 j 的数，则从 i 号点向 j 号点连一条长为 c 的边。<br>
<a href="https://www.luogu.com.cn/training/269062">练习</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[倍增]]></title>
        <id>https://NuclearPasta3579.github.io/post/bei-zeng/</id>
        <link href="https://NuclearPasta3579.github.io/post/bei-zeng/">
        </link>
        <updated>2023-08-08T07:58:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="倍增简介">【倍增简介】</h1>
<p>一种算法，是指利用 2 的指数优化动态求答案的过程，使对应时间复杂度降至 \operatorname{O}(\log n)。</p>
<h1 id="模块">【模块】</h1>
<h2 id="1-普通倍增">1. 普通倍增</h2>
<p>在问题中运用 2 的指数即可。<br>
题目：<br>
<a href="https://www.luogu.com.cn/problem/P1226">快速幂</a><br>
将指数拆成 2 的幂的形式即可。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#define int long long
using namespace std;
int a,b,p;
inline int fast_times(int x,int y){
    int ans=1;
    while(y){
        if(y%2==1)ans=ans*x%p;
        y/=2;
        x=x*x%p;
    }
    return ans;
}
signed main(){
    scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;p);
    printf(&quot;%lld^%lld mod %lld=%lld&quot;,a,b,p,fast_times(a%p,b));
    return 0;
}
</code></pre>
<h2 id="2st表">2.ST表</h2>
<p>一种特殊的数据结构，用于求静态的部分问题，对应问题的前提是出现重复元素不影响答案。<br>
时间复杂度对应 \operatorname{O}(n\log n) 的预处理和 \operatorname{O}(1) 的查询。<br>
<code>ST</code>表通常会分为 \log n + 1 层，从 0 开始编号，第 i 层存储从一个变量起连续 2^i 各元素的答案，查询 [l,r] 时，先求出在第 k=\log(r-l+1) 层，然后求出此层存储由 i 开始的连续变量的答案及由 r 结尾的连续变量的答案综合起来的结果，代码如下：</p>
<pre><code>class ST_novel{
	private:
	int a[100001][39];
	int nt;
	int STMax(int x,int y){//合并两结果方式
		return x&gt;y?x:y;
        
	void copy_to_ST(int num[],int begin,int end){//预处理
		memset(a,~0x3f3f3f3f,sizeof(a));
		nt=end-begin+1;
		for(int i=1;i&lt;=end-begin+1;i++){
			a[i][0]=num[begin+i-1];
		}
		for(int j=1;(1&lt;&lt;j)&lt;=nt;j++){
			for(int i=1;i+(1&lt;&lt;j-1)&lt;=nt;i++){
				a[i][j]=STMax(a[i][j-1],a[i+(1&lt;&lt;j-1)][j-1]);
			}
		}
	}
	int ans(int l,int r){//得出答案
		int k=log2(r-l+1);
		return STMax(a[l][k],a[r-(1&lt;&lt;k)+1][k]);
	}
};
</code></pre>
<p>题目：<br>
<a href="https://www.luogu.com.cn/training/260909">在这里</a></p>
<h2 id="树状数组">树状数组</h2>
<p>是另一种数据结构，用于 \operatorname{O}( \log n) 求动态修改和求前缀的答案，它的建立过程如下：</p>
<ol>
<li>将全段的答案存入根节点；</li>
<li>将一段的左半段答案存入左儿子，右半段的存入右儿子直到所有叶节点只对应一个元素的节点为止（此时是线段树）。</li>
<li>去掉所有节点的右儿子，每个右儿子的左儿子连向那个右儿子的父亲节点。</li>
</ol>
<p>此时我们得到的结果如下：</p>
<pre><code>++++++++
|    |  |
++++ |  |
|  | |  |
++ | ++ |
|  | |  |
+  + +  +
</code></pre>
<p>我们将节点按后序遍历编号，得：</p>
<pre><code>+++8++++
|    |  |
+4++ |  |
|  | |  |
2+ | 6+ |
|  | |  |
1  3 5  7
</code></pre>
<p>我们用 \operatorname{lowbit}(x) 求他在二进制下位数最小的 1 的位值，<br>
易知：</p>
<ol>
<li>我们更新第 x 个变量时，要从 x 号节点开始，向上遍历，对应 x+\operatorname{lowbit}(x) 号节点；</li>
<li>我们查询一个点为止的前缀时,从 x 开始，到 x-\operatorname{lowbit}(x) 进行求答，直到 x=0 为止。</li>
</ol>
<p>故而无需搜索，只需套遍历的方式在数组上遍历即可。<br>
模板：</p>
<pre><code class="language-cpp">class tree{
	private:
	long long spi[65590],nk;
	long long lowbit(long long xfd){
		return xfd&amp;(-xfd);
	}
	public:
    long long isp(long long h){
		long long ans=0;
		for(long long i=h;i&gt;0;i-=lowbit(i)){
			ans+=spi[i];
		}
		return ans;
	}
	void init(long long l){
		nk=1;
		while(nk&lt;l)nk=nk*2;
		for(long long i=1;i&lt;=nk;i++){spi[i]=0;}
	}
	void add(long long place,long long number){
		for(long long i=place;i&lt;=nk;i+=lowbit(i)){
			spi[i]+=number;
        }
	}
	long long query(long long lsp,long long rsp){
		return isp(rsp)-isp(lsp-1);
	}
};
</code></pre>
<p><a href="https://www.luogu.com.cn/training/260951">例题</a></p>
<h2 id="倍增表">倍增表</h2>
<p>此处用 f_{i,j} 求从第 i 个元素移动 2^j 的对应答案，模板如下：</p>
<pre><code>int f[100001][20];
//这里可以定义成所有类型。
inline void ycl(int i,int fp){//i指初始点，fp指第一步跳到的点
	f[i][0]=fp;
	int j=1;
	while(f[i][j-1]!=Not_Exist){//Not_Exist 可以为任意可代表不存在的值
		f[i][j]=f[f[i][j-1]][j-1];
	}
}
</code></pre>
<p>可以用作求<code>lca</code>，预处理和查询复杂度都是 \operatorname{O}(\log n)。<br>
<a href="https://www.luogu.com.cn/training/260956">例题</a></p>
<h1 id="例题精讲">【例题精讲】</h1>
<p><a href="https://www.luogu.com.cn/problem/CF519E">题目传送门</a></p>
<h2 id="思路">思路</h2>
<h3 id="引理一两点之间最短路以外的点是否是答案取决于最近的最短路上的点">引理一：两点之间最短路以外的点是否是答案取决于最近的最短路上的点</h3>
<p>由于树上两个点只有一条路径，故而无需考虑其他路径，<br>
设这个点为 y ,离问题中两点最短路径 x 最近，那么它们会先走到 x 号节点，再去 y 号节点，它们同时走过 x 至 y 的路径，故而我们只需考虑到 x 的路径即可。</p>
<h3 id="找路径上的答案节点">找路径上的答案节点</h3>
<p>由于当一个节点属于答案时，它在路径上怎么走，都会改变到问题所问两点的距离，故而至多只有一个路劲上的答案。<br>
如果两点距离为奇数，没有答案。<br>
若为偶数，这从一个节点走距离的一半到达的节点即为所求。<br>
为了简便，我们用深度较大的节点完成全过程。</p>
<h3 id="通过答案节点推其它答案">通过答案节点推其它答案</h3>
<p>我们易知答案节点的子树由非问题两点最短路径到达的子节点到达路径时必先到该节点，符合条件。<br>
同时如果该节点是所问两点的<code>lca</code>，则非路径到达的点是祖先的情况也要算进去。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
int n,m,x,t;
struct edge{
   int to,nxt; 
}e[200001];
int s[100001];
inline void add(int x,int y,int z){
    e[z*2-1]=edge{y,s[x]};
    e[z*2]=edge{x,s[y]};
    s[x]=z*2-1;
    s[y]=z*2;
}
int sz[100001],f[100001][20],d[100001];
inline void srh(int nk,int l){
	f[nk][0]=l;
	d[nk]=d[l]+1;
	int olp=0;
	while(f[nk][olp]!=0){
		olp++;
		f[nk][olp]=f[f[nk][olp-1]][olp-1];
	}
	sz[nk]=1;
	for(int i=s[nk];i!=0;i=e[i].nxt){
		if(e[i].to==l)continue;
		srh(e[i].to,nk);
		sz[nk]+=sz[e[i].to];
	}
}
inline int skip(int x,int o){
	for(int i=18;i&gt;=0;i--){
		if(o&gt;=(1&lt;&lt;i)){
			o-=(1&lt;&lt;i);
			x=f[x][i];
		}
	}
	return x;
}
inline int fnd_lca(int x,int y){
	if(d[x]&lt;d[y]){
		int t=x;
		x=y;
		y=t;
	}
	x=skip(x,d[x]-d[y]);
	if(x==y)return x;
	for(int i=18;i&gt;=0;i--){
		if(f[x][i]!=f[y][i]){
			x=f[x][i],y=f[y][i];
		}
	}
	return f[x][0];
}
inline void cin(int &amp;x){
    x=0;
    bool f=false;
    char c;
    while((c&lt;'0'||c&gt;'9')&amp;&amp;c!='-')c=getchar();
    if(c=='-'){
        f=true;
        c=getchar();
    }
    while(c&lt;='9'&amp;&amp;c&gt;='0'){
        x=x*10+c-'0';
        c=getchar();
    }
    if(f)x=-x;
}
inline void cout(int f){
    if(f&lt;0){
    putchar('-');
    f=-f;
   }
   if(f&gt;=10)cout(f/10);
   putchar(f%10+'0');
}
int main(){
	cin(n);
	for(int i=1;i&lt;n;i++){
		cin(x),cin(t);
		add(x,t,i);
	}
	srh(1,0);
	cin(m);
	for(int i=1;i&lt;=m;i++){
		cin(x),cin(t);
		if(x==t)cout(n);
		else if((d[x]+d[t])%2!=0)cout(0);
		else if(d[x]==d[t])
			cout(sz[1]-sz[skip(x,d[x]-d[fnd_lca(x,t)]-1)]-sz[skip(t,d[t]-d[fnd_lca(x,t)]-1)]);
		else {
			if(d[x]&gt;d[t]){
				cout(sz[skip(x,(d[x]+d[t])/2-d[fnd_lca(x,t)])]-sz[skip(x,(d[x]+d[t])/2-d[fnd_lca(x,t)]-1)]);
			}
			else{
				cout(sz[skip(t,(d[x]+d[t])/2-d[fnd_lca(x,t)])]-sz[skip(t,(d[x]+d[t])/2-d[fnd_lca(x,t)]-1)]);
			}
		}
		putchar('\n');
	}
	return 0;
}

</code></pre>
<h1 id="拓展练习">【拓展练习】</h1>
<p><a href="https://www.luogu.com.cn/training/260957">这里</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[双指针]]></title>
        <id>https://NuclearPasta3579.github.io/post/shuang-zhi-zhen/</id>
        <link href="https://NuclearPasta3579.github.io/post/shuang-zhi-zhen/">
        </link>
        <updated>2023-08-08T07:54:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="双指针简介">双指针简介</h1>
<p>双指针是指通过一种形式，使得可以通过一组指针推出另一组指针，且所有指针只向一个方向移动。常用于单调性优化。</p>
<h1 id="例题">例题</h1>
<p><a href="https://www.luogu.com.cn/training/264580#problems">地址</a></p>
<h1 id="精讲">精讲</h1>
<p><a href="https://www.luogu.com.cn/problem/P3117">题目传送门</a></p>
<h2 id="题意">题意</h2>
<p>给出两种点及其所在的位置，你需要找到最小的矩形，使其不包含第二种点，且包含最多的第一种点。</p>
<h2 id="解法">解法</h2>
<p>首先，你需要离散化，然后枚举一个维度的两端，再用三个指针来跑另一个维度，其中枚举第一个指针，第二个指针在指向行在第一位的两个列中出现第二种点停下，第二种点停下前，如果对应出现第一种点，让第三个指针指向它，用第三个指针更新答案，之后第一个指针从第二个指针后开始枚举。</p>
<h2 id="代码">代码</h2>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
int n,tox[1001],bkx[501],toy[1001],bky[501],ans1=0,ans2=0x3f3f3f3f;
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q,q1;
int h[501][501],g[501][501],l,r,cnt1,cnt2,p;
int lp[501],tp[501];
char kd[501];
int min(int a,int b){
    return a&lt;b?a:b;
}
int main(){
    //读入
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%d %d %c&quot;,&amp;lp[i],&amp;tp[i],&amp;kd[i]);
        q.push(lp[i]);
        q1.push(tp[i]);
    }
    //离散化
    while(!q.empty()){
        int d=q.top();
        q.pop();
        if(tox[d])continue;
        tox[d]=++cnt1;
        bkx[cnt1]=d;
    }
    while(!q1.empty()){
        int d=q1.top();
        q1.pop();
        if(toy[d])continue;
        toy[d]=++cnt2;
        bky[cnt2]=d;
    }
    //求答案
    for(int i=1;i&lt;=n;i++){
        if(kd[i]=='H')h[tox[lp[i]]][toy[tp[i]]]++;
        else g[tox[lp[i]]][toy[tp[i]]]++;
    }
    for(int i=1;i&lt;=cnt1;i++){
        for(int j=1;j&lt;=cnt2;j++){
            h[i][j]+=h[i][j-1]+h[i-1][j]-h[i-1][j-1];
            g[i][j]+=g[i][j-1]+g[i-1][j]-g[i-1][j-1];
        }
    }
    for(int i=1;i&lt;=cnt1;i++){
        for(int j=1;j&lt;=i;j++){
            r=1;
            for(l=1;l&lt;=cnt2;l++){
                while(l&lt;=cnt2&amp;&amp;(g[i][l]-g[i][l-1]-g[j-1][l]+g[j-1][l-1]&gt;0||h[i][l]-h[i][l-1]-h[j-1][l]+h[j-1][l-1]&lt;=0))l++;
                if(l&gt;cnt2)break;
                r=p=l;
                while(r&lt;cnt2&amp;&amp;g[i][r+1]-g[i][l-1]-g[j-1][r+1]+g[j-1][l-1]&lt;=0){
                    r++;
                    if(h[i][r]-h[i][r-1]-h[j-1][r]+h[j-1][r-1]&gt;0)p=r;
                }
                if(h[i][p]-h[i][l-1]-h[j-1][p]+h[j-1][l-1]&gt;ans1){
                    ans1=h[i][p]-h[i][l-1]-h[j-1][p]+h[j-1][l-1];
                    ans2=(bkx[i]-bkx[j])*(bky[p]-bky[l]);
                }
                else if(h[i][p]-h[i][l-1]-h[j-1][p]+h[j-1][l-1]==ans1){
                    ans2=min(ans2,(bkx[i]-bkx[j])*(bky[p]-bky[l]));
                }
                l=r+1;
            }
        }
    }
    printf(&quot;%d\n%d&quot;,ans1,ans2);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[生成树与最小生成树]]></title>
        <id>https://NuclearPasta3579.github.io/post/sheng-cheng-shu-yu-zui-xiao-sheng-cheng-shu/</id>
        <link href="https://NuclearPasta3579.github.io/post/sheng-cheng-shu-yu-zui-xiao-sheng-cheng-shu/">
        </link>
        <updated>2023-08-08T07:54:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="定义">【定义】</h1>
<h2 id="生成树">生成树</h2>
<p>以一张无向图,用无向图的部分边及所有点。</p>
<h2 id="最小生成树">最小生成树</h2>
<p>其中所有边之和最小的树是最小生成树。</p>
<h2 id="次小生成树">次小生成树</h2>
<p>其中所有边之和第二小的树是最小生成树。<br>
分为非严格次小生成树和严格次小生成树，其中非严格次小生成树的边权和<strong>允许</strong>和最小生成树<strong>相同</strong>，而严格次小生成树<strong>不许相同</strong></p>
<h1 id="最小生成树算法">【最小生成树算法】</h1>
<h2 id="kruskal">kruskal</h2>
<p>将边按边权从小到大进行排序，然后遍历每条边。<br>
对于一条边，当且仅当边两端未联通时加入此边，通常用<a href="https://www.luogu.com.cn/blog/lcm15987/zhou-ji-zhi-bing-zha-ji">并查集</a>存储联通关系。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
long long n,m,ans=0,s=0;
long long u,v,w;
long long b[200003],r[200003];
struct edge{
    long long st,ed,len;
}e[200001];
bool ps(edge x,edge y){
    return x.len&lt;y.len;
}
long long find(long long x){
    if(b[x]!=x)return b[x]=find(b[x]);
    return b[x];
}
void get_in(long long x,long long y,long long k)
{
    long long u=find(x),v=find(y);
    if(u==v)return;
    ans+=k;
    s++;
    if(r[u]&gt;r[v])b[v]=u;
    else if(r[u]&lt;r[v])b[u]=v;
    else{
        b[v]=u;
        r[u]++;
    }
}
int main(){
    scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m);
    for(long long i=1;i&lt;=n;i++)
        b[i]=i;
    for(long long i=1;i&lt;=m;i++){
        scanf(&quot;%lld%lld%lld&quot;,&amp;e[i].st,&amp;e[i].ed,&amp;e[i].len);
    }
    sort(e+1,e+m+1,ps);
    for(long long i=1;i&lt;=m;i++){
        if(s==n-1)break;
        get_in(e[i].st,e[i].ed,e[i].len);
    }
    if(s==n-1)
        printf(&quot;%lld\n&quot;,ans);
    else
        printf(&quot;orz\n&quot;);
    return 0;
}
</code></pre>
<h2 id="prim">prim</h2>
<p>从一个点开始，选取一个集连出的边中最小的边，然后将边的另一端加入集，实现是边权会存入边中。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
unsigned long long n,m,s,t,u,v,w,dist[500001];
bool vis[500001];
struct edge{
	unsigned long long ed,len;
	
};
bool operator&lt;(edge mk,edge k){
		return mk.len&gt;k.len;
	}
vector&lt;edge&gt;e[500001];
priority_queue&lt;edge&gt;q;
void Dijkstra(unsigned long long begin){
	memset(dist,0x3f3f3f3f,sizeof(dist));
	memset(vis,false,sizeof(vis));
	q.push(edge{begin,0});
	dist[begin]=0;
	while(!q.empty()){
		edge d=q.top();
		q.pop();
		if(vis[d.ed])continue;
		vis[d.ed]=true;
		for(unsigned long long i=0;e[d.ed].size()&gt;i;i++){
			if(dist[e[d.ed][i].ed]&gt;e[d.ed][i].len&amp;&amp;!vis[e[d.ed][i].ed]){
				dist[e[d.ed][i].ed]=e[d.ed][i].len;
				q.push(edge{e[d.ed][i].ed,dist[e[d.ed][i].ed]});
			}
		}
	}
}
int main(){
	scanf(&quot;%llu%llu&quot;,&amp;n,&amp;m);
	for(unsigned long long i=1;m&gt;=i;i++){
		scanf(&quot;%llu%llu%llu&quot;,&amp;u,&amp;v,&amp;w);
		e[u].push_back(edge{v,w});
		e[v].push_back(edge{u,w});
	}
	Dijkstra(1);
	for(unsigned long long i=1;i&lt;=n;i++){
	    if(!vis[i]){printf(&quot;orz&quot;);return 0;}
	    else s+=dist[i];
	}
	printf(&quot;%llu\n&quot;,s);
	return 0;
}
</code></pre>
<h1 id="常见题型">【常见题型】</h1>
<h2 id="1裸最小生成树与较为简单的变形">1.裸最小生成树与较为简单的变形</h2>
<h3 id="对应题目">对应题目</h3>
<ol>
<li><a href="https://www.luogu.com.cn/problem/P3366">【模板】最小生成树</a></li>
<li><a href="https://www.luogu.com.cn/problem/T243516">安慰奶牛</a></li>
<li><a href="https://www.luogu.com.cn/problem/T243505">北极通讯网络</a></li>
<li><a href="https://www.luogu.com.cn/problem/T243518">构造完全图</a></li>
<li><a href="https://www.luogu.com.cn/problem/P2872">[USACO07DEC]Building Roads S</a></li>
<li><a href="https://www.luogu.com.cn/problem/T243511">灌溉农田</a></li>
<li><a href="https://www.luogu.com.cn/problem/P2330">[SCOI2005]繁忙的都市</a></li>
<li><a href="https://www.luogu.com.cn/problem/P2820">局域网</a></li>
<li><a href="https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/E">E. Spanning Tree</a></li>
<li><a href="https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/F">F. Dense spanning tree</a></li>
<li><a href="https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/G">G. No refuel</a></li>
<li><a href="https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/H">H. Oil business</a></li>
</ol>
<h3 id="思路">思路</h3>
<p>简单地想一想怎么用最小生成树算法做即可。</p>
<h2 id="2次小生成树">2.次小生成树</h2>
<h3 id="对应题目-2">对应题目</h3>
<ol>
<li><a href="https://www.luogu.com.cn/problem/T243521">秘密牛奶运输</a></li>
</ol>
<h3 id="思路-2">思路</h3>
<p>求出最小生成树后，依次加入非树边，然后去掉对应环中其他边中边权最大的，求严格次小生成树时最大边若与非树边边权相同去次大边。<br>
优化后将变得飞快，本博主用的是倍增。</p>
<h2 id="3较为困难的变形">3.较为困难的变形</h2>
<h3 id="对应题目-3">对应题目</h3>
<ol>
<li><a href="https://www.luogu.com.cn/problem/P1967"> [NOIP2013 提高组] 货车运输</a></li>
<li><a href="https://www.luogu.com.cn/problem/P2619">[国家集训队]Tree I</a></li>
<li><a href="https://www.luogu.com.cn/problem/P4208">[JSOI2008]最小生成树计数</a></li>
<li><a href="https://www.luogu.com.cn/problem/P2573">[SCOI2012]滑雪</a></li>
</ol>
<h3 id="思路-3">思路</h3>
<p>思考最小生成树解。</p>
<h1 id="例题精讲">【例题精讲】</h1>
<p>题目：<a href="https://www.luogu.com.cn/problem/P2573">[SCOI2012]滑雪</a><br>
方法：使用<code>Prim</code>算法，当一点高度比另一点高时遍历将另一点加入集，高度高的优先遍历，其次才是对应边权小的。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;
int n,t,m; 
int u,v,w,dist[100001],h[100001];
bool vis[100001];
struct edge{
	int ed,len;
};
bool operator&lt;(edge mk,edge k){
    if(h[mk.ed]!=h[k.ed])return h[mk.ed]&lt;h[k.ed];
	return mk.len&gt;k.len;
}
long long ans=0;
vector&lt;edge&gt;e[100001];
priority_queue&lt;edge&gt;q;
void Dijkstra(int begin){
	memset(dist,0x3f3f3f3f,sizeof(dist));
	memset(vis,false,sizeof(vis));
	q.push(edge{begin,0});
	dist[begin]=0;
	while(!q.empty()){
		edge d=q.top();
		q.pop();
		if(vis[d.ed])continue;
		vis[d.ed]=true;
		ans+=1ll*dist[d.ed];
		t++;
		for(int i=0;e[d.ed].size()&gt;i;i++){
			if(h[d.ed]&gt;=h[e[d.ed][i].ed]&amp;&amp;dist[e[d.ed][i].ed]&gt;e[d.ed][i].len&amp;&amp;!vis[e[d.ed][i].ed]){
				dist[e[d.ed][i].ed]=e[d.ed][i].len;
				q.push(edge{e[d.ed][i].ed,dist[e[d.ed][i].ed]});
			}
		}
	}
}
int main(){
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
	    scanf(&quot;%d&quot;,&amp;h[i]);
	}
	for(int i=1;i&lt;=m;i++){
	    scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
	    e[u].push_back(edge{v,w});
	    e[v].push_back(edge{u,w});
	}
	Dijkstra(1);
	printf(&quot;%d %lld\n&quot;,t,ans);
	return 0;
}
</code></pre>
<p><a href="https://cdn.luogu.com.cn/upload/image_hosting/momg4ciq.png">AC记录</a></p>
<h1 id="总结">【总结】</h1>
<p>最小生成树是一种图论的问题，通过<code>Kruskal</code>和<code>Prim</code>我们可以想出解来。</p>
<h1 id="拓展">【拓展】</h1>
<p><a href="https://www.luogu.com.cn/training/256184">尽在此处。</a></p>
]]></content>
    </entry>
</feed>